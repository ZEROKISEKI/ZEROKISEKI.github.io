{"pages":[{"title":"404","text":"","path":"404/index.html","date":"12-30","excerpt":""},{"title":"关于我","text":"标签: ACG控 | falcom(法老控) | 幼刀控柚子控 | 八月控 | 代码控 狡兔三窟, 换过几次blog, 最终在godday买了个.moe域名新的blog, 新的开始。","path":"about/index.html","date":"12-30","excerpt":""},{"title":"分类","text":"","path":"categories/index.html","date":"12-30","excerpt":""},{"title":"search","text":"","path":"search/index.html","date":"12-30","excerpt":""},{"title":"留言板","text":"有什么问题或想说的可以在这里讲哦~","path":"message/index.html","date":"12-30","excerpt":""},{"title":"标签","text":"","path":"tags/index.html","date":"12-30","excerpt":""}],"posts":[{"title":"即将到来的2018","text":"还有两天, 就是2018了, 我也即将毕业2017做了什么？ 没做什么, 就是正常的大学过程，跟同学，跟朋友，实习等等然后就是, 在2017，终于踏入了gal的坑里面了, 这一年约莫有玩了30多部gal吧(虽然大多数都是单线)感觉不用操作的游戏更适合我了, 其他的游戏，倒是愿意去看别人的直播我读的是计算机专业, 还是很庆幸读这个专业, 这个专业算是培养了我去折腾东西的”兴趣“… 关于接下来的2018关于工作:大学里面关于IT, 学的算是比较杂, 主要玩的是前端, 如你所见这个blog的主题是自己写的, 玩过逆向工程, 玩过python等等之前自己的想法是主搞前端, 做一个前端程序员, 学其他的, 只是为了工作时能更方便罢了 不过, 去实习之后, 虽然做得不错, 但是发现我可能并不想当一名程序员, 虽然已经拿到了一些offer, 但是都不是很想去, 在家里人的劝说下, 去参加了2018的国考有点可笑, 说自己喜欢代码, 但又不想当程序员, 我自己都觉得矛盾, 可能就像《白马啸西风》李文秀的那句话那样: “那些都是很好很好的，可我偏偏不喜欢” 而考公选的是自己居住的城市(潮汕某三或四线城市), 一则求稳, 二则不想要那么快的生活节奏, 对小城市也没什么排斥感, 缓慢的生活节奏更适合我(至少目前是这么想) 关于兴趣和爱好:开始对很多领域感兴趣, 自从alphago横空出世以来, 开始掀起机器学习的热潮, 目前有一个很热门的东西叫tensorflow, 关于这方面挺感兴趣, 想找个时间学一下已经有相当长的时间没玩过逆向工程了, 会重新拾起这一方面的东西重新拾起python, 学习golang认真去学下日语, 毕竟汉化的gal已经满足不了我了2333, 顺便也当为研究下汉化做个铺垫 …再说下去我怕到时会不想再看这篇文章了 总之, 提前祝愿一下2018了。","path":"2017/12/30/helloWorld/","date":"12-30","excerpt":"还有两天, 就是2018了, 我也即将毕业2017做了什么？ 没做什么, 就是正常的大学过程，跟同学，跟朋友，实习等等然后就是, 在2017，终于踏入了gal的坑里面了, 这一年约莫有玩了30多部gal吧(虽然大多数都是单线)感觉不用操作的游戏更适合我了, 其他的游戏，倒是愿意去看别人的直播我读的是计算机专业, 还是很庆幸读这个专业, 这个专业算是培养了我去折腾东西的”兴趣“…","preview":"http://p1r8dwfrm.bkt.clouddn.com/helloworld/preview.jpg"},{"title":"制作一个不轻量的hexo主题:cube","text":"建议每篇文章都加上自己的preview的url地址 前言之前自己用Laravel写了个博客, 用了一段时间果断弃之, 又用回了原来的Hexo, 上网找了下主题, 没找到自己想要的, 于是决定自己写一款主题(在写主题的过程倒是找到了很多自己觉得不错的2333), 这篇文章只是用来记录一下最近这段时间写这个主题的过程, 中间存在着很多的问题, 主题目前还没有正式完成, 最近实习 + 毕设搞得比较颓, 9月份之后会逐步完善修复。 hexo-theme-cubecube-generator示例网站 其中cube-generator是主题的生成器, 通过运行对应的gulp命令能够重新生成主题cube 构建主题看了一些github上的主题项目, 很多都是ES5 + jQuery的实现方式, 于是自己有了一个想法，用ES6来写这个主题样式, 最终代码是要转化为ES5的, 那么就需要babel进行转换了, 又因为写样式决定采用SaSS, 所以就决定用gulp进行自动化构建, 所以最终的决定是: gulp中利用browserify + babelify对前端代码进行ES6到ES5的转换, Babel转换的规则写在babelify上面, js代码的入口规定为source/js/app.js, app.js中import对应功能的js代码, gulp进行bundle script的生成代码如下: const b = browserify({ cache: {}, packageCache: {}, entries: path.join(&apos;./source/js/app.js&apos;), debug: true }) // 配置babel转换规则 b.transform(babelify, { presets: [&apos;env&apos;, &apos;es2015&apos;, &apos;stage-2&apos;], plugins: [[&apos;transform-runtime&apos;, { &apos;polyfill&apos;: true, &apos;regenerator&apos;: true }]] }) gulp.task(&apos;buildScript&apos;, bundle) // b.on(&apos;update&apos;, bundle) // bundle生成script.js并且放在cube/source/js/script.js上面 function bundle() { return b.bundle() .on(&apos;error&apos;, err =&gt; console.log(err)) .pipe(source(&apos;script.js&apos;)) .pipe(buffer()) .pipe(sourcemaps.init({ loadMaps: true })) .pipe(uglify()) .pipe(sourcemaps.write(&apos;./&apos;)) .pipe(gulp.dest(path.join(Path.theme, Path.source, &apos;/js&apos;))) } JS的部分如下所示: 在gulp中利用gulp-inject, 将source/sass/目录下除了style.scss的.scss文件用@import的方式进行注入,最后再对style.scss用gulp-sass进行编译生成最终的css文件, 代码如下: // highlight和lightgallery已经在其他文件通过@import的方式引用了索引文件 // 所以这里不注入对应文件夹里面的文件 function buildStyle() { const injectFiles = gulp.src([ path.join(Path.source, &apos;sass/*.scss&apos;), &apos;!&apos; + path.join(Path.source, &apos;sass/highlight/*.scss&apos;), &apos;!&apos; + path.join(Path.source, &apos;sass/lightgallery/*.scss&apos;), &apos;!&apos; + path.join(Path.source, &apos;/sass/style.scss&apos;) ], { read: false }) const injectOptions = { transform(filePath) { filePath = filePath.replace(`${Path.source}/sass/`, &apos;&apos;); filePath = filePath.replace(&apos;_&apos;, &apos;&apos;); return `@import &quot;${filePath}&quot;;` }, starttag: &apos;// injector&apos;, endtag: &apos;// endinjector&apos;, addRootSlash: false } return gulp.src(path.join(Path.source, &apos;/sass/style.scss&apos;)) .pipe(Inject(injectFiles, injectOptions)) .pipe(Sass()) .pipe(postcss([ autoprefixer() ])) .pipe(cleanCss({debug: true})) .pipe(gulp.dest(path.join(Path.theme, Path.source, &apos;/css&apos;))) } 将上面两部生成的script.js和style.css注入到header.ejs和layout.ejs(注入的其实是ejs的模板写法), 然后将ejs文件，字体和图片等静态资源移动到主题文件夹中，将主题文件夹放置到Hexo站点的themes文件夹里面, 完成主题的生成: gulp.task(&apos;injectStyle&apos;, [&apos;buildStyle&apos;], () =&gt; { const injectStyle = gulp.src(path.join(Path.theme, Path.source,&apos;/css/style.css&apos;), { read: false }) const injectOptions = { starttag: &apos;&lt;!-- inject:style --&gt;&apos;, addRootSlash: false, transform(filePath) { return `&lt;link href=&quot;&lt;%- url_for(&apos;css/${filePath}&apos;) %&gt;&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot;&gt;` }, ignorePath: path.join(Path.theme, Path.source, &apos;css&apos;) } return gulp.src(path.join(Path.layout, &apos;/_partial/head.ejs&apos;)) .pipe(Inject(injectStyle, injectOptions)) .pipe(gulp.dest(path.join(Path.theme, Path.layout, &apos;_partial&apos;))) }) gulp.task(&apos;injectScript&apos;, [&apos;buildScript&apos;], () =&gt; { const injectScript = gulp.src(path.join(Path.theme, Path.source, &apos;/js/script.js&apos;), { read: false }) const injectOptions = { starttag: &apos;&lt;!-- inject:script --&gt;&apos;, addRootSlash: false, transform(filePath) { return `&lt;script src=&quot;&lt;%- url_for(&apos;js/${filePath}&apos;) %&gt;&quot;&gt;&lt;/script&gt;` }, ignorePath: path.join(Path.theme, Path.source, &apos;js&apos;) } return gulp.src(path.join(Path.layout, &apos;/layout.ejs&apos;)) .pipe(Inject(injectScript, injectOptions)) .pipe(gulp.dest(path.join(Path.theme, Path.layout))) }) gulp.task(&apos;inject&apos;, [&apos;injectStyle&apos;, &apos;injectScript&apos;], () =&gt; { return gulp.src([ &apos;!&apos; + path.join(Path.layout, &apos;/layout.ejs&apos;), &apos;!&apos; + path.join(Path.layout, &apos;/_partial/head.ejs&apos;), path.join(Path.layout, &apos;/**/*.ejs&apos;) ]).pipe(gulp.dest(path.join(Path.theme, Path.layout))) }) 通过这两个任务产生的ejs代码如下: layout.ejs: &lt;!-- inject:script --&gt; &lt;script src=&quot;&lt;%- url_for(&apos;js/script.js&apos;) %&gt;&quot;&gt;&lt;/script&gt; &lt;!-- endinject --&gt; _partial/head.ejs: &lt;!-- inject:style --&gt; &lt;link href=&quot;&lt;%- url_for(&apos;css/style.css&apos;) %&gt;&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot;&gt; &lt;!-- endinject --&gt; 通过gulp-watch监听对应领域的文件, 如果发生了变动就重新生成主题 通过上面四个步骤的构建, 就可以在source/js/里面编写es6代码了, 开启gulp watch之后会监听对应模板和scss以及js等文件的变化重新生成主题(用node 子进程进行了hexo clean &amp; hexo g, 只要等待终端提示即可直接hexo s查看效果 博客的构建Hexo博客的构建没什么特别的, 可以参考github上一些优秀的Hexo主题项目的布局格式, 结合Hexo官方文档, 在对应的模板ejs引用对应的Hexo变量实现主题模板的编写即可。关于这个主题的具体构建代码可以看cube-generator 待解决问题 gulp的构建写得还是很乱, 原本的想法是想用browser-sync实现修改文件实时刷新的, 但是hexo启动服务器采用的是hexo s启动, 要先通过hexo g重新生成public文件夹才会刷新内容, 所以用browser-sync的想法也不了了之,后续有时间要把gulp的构建重新写一遍 移动端方面做的调试不多, 貌似在一些手机浏览器会出现一些奇怪的问题(我的小米4自带的原生浏览器加载不了用lightgallery读取的图片, 我觉得这个不是我的锅233, 但是有时间还是要看看)，highlight.js加载较慢导致手机打开博客页面一开始可以横向滚动(应该是我用了async进行异步的关系) 第三方评论系统只测试了畅言和gitment, disqus因为我这边暂时无法那个(你懂的), 所以这个部分还没写, 很多评论系统都挂了，所以在想是不是要自己也来写个评论系统2333 其他一些奇奇怪怪的问题….","path":"2017/08/15/制作一个不轻量的hexo主题-cube/","date":"08-15","excerpt":"建议每篇文章都加上自己的preview的url地址","preview":"http://cube-1252774894.cosgz.myqcloud.com/previews/制作一个不轻量的hexo主题.png"},{"title":"xampp + phpstorm的简单配置","text":"此主题要求more前面的内容是纯文本，即markdown会解析成p元素最好 前期准备安装以下东东： XAMPP PhpStorm(如果有学生邮箱，请到jetbrains官网下载正版，可以免费使用正版，如果没有，百度下载，并下载注册机) 配置XAMPP如下图，安装了apache之后，可以在httpd.conf文件配置监听端口: 在Actions那里可以点击启动或者停止服务，这样的话用XAMPP无脑搭建环境的方式就成功了。 配置PhpStorm先给PhpStorm设置好php interpreter，在File-&gt;Settings里面，搜索php,设置好php语言版本,CLI Interpreter的路径选择你安装的php或者xampp自带的php，如图所示，我选择的是xampp自带的php，PhpStorm自动显示出了php版本： 我们上面配置了Apache，随便建立一个工程，创建一个php文件，写下echo 1;之类的，然后run，但是此时在PhpStorm上run的时候是无效的，这是因为我们还没配置好PhpStorm server, 在Settings里面搜索server,然后添加一个配置，name的话自定义，Host设置为localhost，Port设置为XAMPP Apache配置的端口(比如我的是8080，那么这里就填8080),Debugger选择Xdebug，具体配置后面再讲，配置图如下所示： 然后在Tools-&gt;Deployment-&gt;Configuration里面进行Apache路径的指向： 然后是配置Run/Debug Configurations,点击右上角绿箭头左边的下拉框，有个Edit Configurations，点击这个可以配置Run/Debug的支持,点进去后，点击左上角的“+”符号,选择PHP Web Application,名字自定，Server选择之前配置的Server,Start Url指定了你点击Run的时候默认的路径，配置如下图所示： 确保Apache服务已经开启，然后就可以测试是否连接成功了。 Xdebug的配置在PhpStorm中，进入File-&gt;Settings,然后搜索Debug，如下图所示配置： 然后点击Debug,确定Debug Port为上面配置的端口,其他默认: 然后是php方面的Xdebug配置，首先你要确保PhpStorm引用的php解析有Xdebug的支持，如下图所示(我这里用的是XAMPP的php)： $ php -v PHP 5.5.19 (cli) (built: Nov 12 2014 12:35:44) Copyright (c) 1997-2014 The PHP Group Zend Engine v2.5.0, Copyright (c) 1998-2014 Zend Technologies with Xdebug v2.2.5, Copyright (c) 2002-2014, by Derick Rethans $ php -m [PHP Modules] bcmath bz2 calendar Core ctype curl date dom ereg exif filter ftp gd gettext hash iconv json libxml mbstring mcrypt mhash mysql mysqli mysqlnd odbc openssl pcre PDO pdo_mysql pdo_sqlite Phar Reflection session SimpleXML soap sockets SPL sqlite3 standard tokenizer wddx xdebug xml xmlreader xmlrpc xmlwriter xsl zip zlib [Zend Modules] Xdebug 如果没有，那么百度下载Xdebug.dll，然后在php.ini进行如下配置(在php.ini中搜索Xdebug)： zend_extension = &quot;C:\\xampp\\php\\ext\\php_xdebug.dll&quot; //这里的路径替换成你下载的xdebug.dll的路径，版本貌似要2.2.5以上 然后在php.ini进行如下配置： xdebug.profiler_append = 0 xdebug.profiler_enable = 1 xdebug.profiler_enable_trigger = 0 xdebug.profiler_output_dir = &quot;C:\\xampp\\tmp&quot; //注意路径替换成你的Xampp路径 xdebug.profiler_output_name = &quot;cachegrind.out.%t-%s&quot; xdebug.trace_output_dir = &quot;C:\\xampp\\tmp&quot; //上同 xdebug.remote_enable = on xdebug.remote_handler = dbgp xdebug.remote_host = localhost //下面三行为我们之前在PhpStorm配置的参数 xdebug.idekey= PhpStorm xdebug.remote_port = 9000 给浏览器安装Xdebug helper，Xdebug helper在这里下载，下载后直接拖到浏览器就行了，然后在管理扩展那里设置Xdebug helper: 然后，在PhpStorm中的Run选项，点击Start Listening for PHP Debug Connections。 至此，Xdebug设置完成，下面是Debug测试的画面： 差不多就这样了。","path":"2017/01/11/xampp-phpstorm的简单配置/","date":"01-11","excerpt":"此主题要求more前面的内容是纯文本，即markdown会解析成p元素最好"},{"title":"某crackme破解","text":"这是一次逆向的练习记录 0x00: 前言前两天看雪CTF大赛开始，然而对于看雪的CM题目完全是一脸懵逼，于是决定进行CM的训练，废话不多说，目标是这家伙： 居然还用了diablo的头像hhh，运行界面： 0x01: 脱壳简单说明下，上下两个框都可以输入，如果输入有误，第二个框的值会变成”register unvalid”之类的东西，首先用PEID查下壳：yoda’s crypter的壳，那么就来脱掉它吧~ OD载入程序进行异常计数，然后断在最后一次异常中，此时查看堆栈得知SEH的处理Handle在0040C70C中，于是跳到异常处理函数中，下面是异常处理函数： 0040C70C 55 push ebp 0040C70D 8BEC mov ebp,esp 0040C70F 57 push edi 0040C710 8B45 10 mov eax,dword ptr ss:[ebp+0x10] 0040C713 8BB8 C4000000 mov edi,dword ptr ds:[eax+0xC4] 0040C719 FF37 push dword ptr ds:[edi] 0040C71B 33FF xor edi,edi 0040C71D 64:8F07 pop dword ptr fs:[edi] 0040C720 8380 C4000000 0&gt;add dword ptr ds:[eax+0xC4],0x8 0040C727 8BB8 A4000000 mov edi,dword ptr ds:[eax+0xA4] 0040C72D C1C7 07 rol edi,0x7 0040C730 89B8 B8000000 mov dword ptr ds:[eax+0xB8],edi 0040C736 B8 00000000 mov eax,0x0 0040C73B 5F pop edi 这里edi的值为0x40A950,为跳转到OEP的关键 0040C73C C9 leave 0040C73D C3 retn 跳到edi指向的地址，然后单步跟踪，很快就找到了OEP了，OEP代码如下： 00401000 6A 00 push 0x0 00401002 E8 71020000 call d2k2_crk.00401278 ; jmp 到 kernel32.GetModuleHandleA 00401007 A3 40314000 mov dword ptr ds:[0x403140],eax 0040100C 6A 00 push 0x0 0040100E 68 28104000 push d2k2_crk.00401028 00401013 6A 00 push 0x0 00401015 6A 01 push 0x1 00401017 FF35 40314000 push dword ptr ds:[0x403140] 0040101D E8 62020000 call d2k2_crk.00401284 ; jmp 到 user32.DialogBoxParamA 00401022 50 push eax 00401023 E8 4A020000 call d2k2_crk.00401272 ; jmp 到 kernel32.ExitProcess 00401028 55 push ebp 00401029 8BEC mov ebp,esp 0040102B 817D 0C 1101000&gt;cmp dword ptr ss:[ebp+0xC],0x111 明显的TASM/MASM32程序，于是脱壳，再次查壳： 0x02: 破解一上来先用很low的中文搜索法，如果不行就打算下DLGITEMTEXT的断点试试，但是没想到中文搜索居然成功了: 位置都在附近，随便点进一个看看(下面中文的注释是我写的,英文的是原本就有的)： 004010C2 E8 C9010000 call &lt;jmp.&amp;user32.GetDlgItemTextA&gt; ; 这里应该是要求某种格式 004010C7 83F8 10 cmp eax,0x10 ; 这里的eax是第二个框的值，要求第二个框放16个数 004010CA 75 5D jnz short d2k2_crk.00401129 004010CC 6A 28 push 0x28 004010CE 68 A0304000 push d2k2_crk.004030A0 004010D3 6A 67 push 0x67 004010D5 FF75 08 push dword ptr ss:[ebp+0x8] 004010D8 E8 B3010000 call &lt;jmp.&amp;user32.GetDlgItemTextA&gt; 004010DD 85C0 test eax,eax ; eax是我们的输入值的个数 004010DF 74 20 je short d2k2_crk.00401101 ; 这个是没有输入的跳转 004010E1 83F8 08 cmp eax,0x8 004010E4 7F 2F jg short d2k2_crk.00401115 ; 输入值不能大于8位 004010E6 83F8 01 cmp eax,0x1 ; 这里这个判定有些问题 004010E9 7C 02 jl short d2k2_crk.004010ED 004010EB EB 50 jmp short d2k2_crk.0040113D 004010ED 68 24304000 push d2k2_crk.00403024 ; Name must be at least 2 chars long! 004010F2 6A 68 push 0x68 004010F4 FF75 08 push dword ptr ss:[ebp+0x8] 004010F7 E8 A0010000 call &lt;jmp.&amp;user32.SetDlgItemTextA&gt; 004010FC E9 41010000 jmp d2k2_crk.00401242 00401101 68 04304000 push d2k2_crk.00403004 ; Enter a name! 00401106 6A 68 push 0x68 00401108 FF75 08 push dword ptr ss:[ebp+0x8] 0040110B E8 8C010000 call &lt;jmp.&amp;user32.SetDlgItemTextA&gt; 00401110 E9 2D010000 jmp d2k2_crk.00401242 00401115 68 12304000 push d2k2_crk.00403012 ; Name is too long! 0040111A 6A 68 push 0x68 0040111C FF75 08 push dword ptr ss:[ebp+0x8] 0040111F E8 78010000 call &lt;jmp.&amp;user32.SetDlgItemTextA&gt; 00401124 E9 19010000 jmp d2k2_crk.00401242 00401129 68 48304000 push d2k2_crk.00403048 ; Your Registration Code is invalid! 0040112E 6A 68 push 0x68 00401130 FF75 08 push dword ptr ss:[ebp+0x8] 00401133 E8 64010000 call &lt;jmp.&amp;user32.SetDlgItemTextA&gt; 00401138 E9 05010000 jmp d2k2_crk.00401242 “Thank you for your support”在这段程序的下面，挺靠后的，然后中间有一大段程序，上面的代码中有一个跳转是到那一大段程序中的jmp short d2k2_crk.0040113D,我将下面的程序也给出来： 0040113D 33DB xor ebx,ebx ; 将寄存器都变为0 0040113F 33C9 xor ecx,ecx 00401141 33D2 xor edx,edx 00401143 33FF xor edi,edi 00401145 33F6 xor esi,esi 00401147 8A99 A0304000 mov bl,byte ptr ds:[ecx+0x4030A0] 0040114D 80FB 41 cmp bl,0x41 00401150 7C 07 jl short d2k2_crk.00401159 00401152 80FB 5A cmp bl,0x5A 00401155 7F 0E jg short d2k2_crk.00401165 00401157 EB 1F jmp short d2k2_crk.00401178 00401159 80C3 20 add bl,0x20 ; 值在0-20的会被赋予F 0040115C 80FB 41 cmp bl,0x41 0040115F 7D 02 jge short d2k2_crk.00401163 00401161 B3 46 mov bl,0x46 ; 固定值F 00401163 ^ EB ED jmp short d2k2_crk.00401152 00401165 80EB 20 sub bl,0x20 00401168 80FB 5A cmp bl,0x5A 0040116B 7E 02 jle short d2k2_crk.0040116F 0040116D B3 47 mov bl,0x47 0040116F 80FB 41 cmp bl,0x41 00401172 7D 02 jge short d2k2_crk.00401176 00401174 B3 53 mov bl,0x53 00401176 ^ EB DF jmp short d2k2_crk.00401157 00401178 889A 87304000 mov byte ptr ds:[edx+0x403087],bl ; 赋值给固定的十六位值 0040117E 83C2 02 add edx,0x2 ; 每次循环加2 00401181 41 inc ecx 00401182 3BC8 cmp ecx,eax ; 输入的位数等于循环次数 00401184 ^ 75 C1 jnz short d2k2_crk.00401147 00401186 33C9 xor ecx,ecx 00401188 33D2 xor edx,edx 0040118A 33DB xor ebx,ebx 0040118C 8A99 87304000 mov bl,byte ptr ds:[ecx+0x403087] 00401192 03D3 add edx,ebx ; bl将这个数加给edx 00401194 41 inc ecx 00401195 83F9 10 cmp ecx,0x10 00401198 ^ 75 F2 jnz short d2k2_crk.0040118C ; 循环0x10次，不断加值给edx 0040119A 69C0 FF000000 imul eax,eax,0xFF 004011A0 0FAFD0 imul edx,eax 004011A3 81F2 ABDFEBAC xor edx,0xACEBDFAB ; 关键 004011A9 0FCA bswap edx 004011AB 52 push edx 004011AC 68 00304000 push d2k2_crk.00403000 ; %lX 004011B1 68 18314000 push d2k2_crk.00403118 004011B6 E8 C3000000 call &lt;jmp.&amp;user32.wsprintfA&gt; 004011BB 83C4 0C add esp,0xC 004011BE 33DB xor ebx,ebx 004011C0 33C9 xor ecx,ecx 004011C2 8A99 18314000 mov bl,byte ptr ds:[ecx+0x403118] ; 这个就是上面bswap的edx的值 004011C8 80FB 3A cmp bl,0x3A 004011CB 7C 02 jl short d2k2_crk.004011CF 004011CD EB 09 jmp short d2k2_crk.004011D8 004011CF 80C3 11 add bl,0x11 004011D2 8899 18314000 mov byte ptr ds:[ecx+0x403118],bl 004011D8 41 inc ecx 004011D9 83F9 08 cmp ecx,0x8 004011DC ^ 75 E4 jnz short d2k2_crk.004011C2 004011DE 33DB xor ebx,ebx 004011E0 33C9 xor ecx,ecx 004011E2 33D2 xor edx,edx 004011E4 8A99 18314000 mov bl,byte ptr ds:[ecx+0x403118] ; 这里是对十六位值得奇数位的改变 004011EA 889A 88304000 mov byte ptr ds:[edx+0x403088],bl ; 这里完成对第二个比较的赋值 004011F0 83C2 02 add edx,0x2 004011F3 41 inc ecx 004011F4 83FA 10 cmp edx,0x10 004011F7 ^ 75 EB jnz short d2k2_crk.004011E4 004011F9 33DB xor ebx,ebx 004011FB 33C9 xor ecx,ecx 004011FD 33D2 xor edx,edx 004011FF 33C0 xor eax,eax 00401201 8A9A C8304000 mov bl,byte ptr ds:[edx+0x4030C8] 00401207 8A82 87304000 mov al,byte ptr ds:[edx+0x403087] ; 这两个数据值要相等 0040120D 33C3 xor eax,ebx 0040120F ^ 0F85 14FFFFFF jnz d2k2_crk.00401129 00401215 8A9A C9304000 mov bl,byte ptr ds:[edx+0x4030C9] 0040121B 8A82 88304000 mov al,byte ptr ds:[edx+0x403088] 00401221 04 05 add al,0x5 00401223 38C3 cmp bl,al ; 要满足条件bl-al=5 00401225 ^ 0F85 FEFEFFFF jnz d2k2_crk.00401129 0040122B 83C2 02 add edx,0x2 0040122E 83FA 10 cmp edx,0x10 00401231 ^ 75 CE jnz short d2k2_crk.00401201 00401233 68 6B304000 push d2k2_crk.0040306B ; Thank you for your support! 00401238 6A 68 push 0x68 0040123A FF75 08 push dword ptr ss:[ebp+0x8] 0040123D E8 5A000000 call &lt;jmp.&amp;user32.SetDlgItemTextA&gt; 讲讲这段逻辑的基本思路： 先判断第二个框的值是否是16位的，如果不是，跳转到unvalid 取出第一个框的长度，要求第一个框的长度在2-8个字之间(事实上它那个判断逻辑有点问题，应该1个字节也是可以的) 判断无误后，进入生成注册码算法 # 生成注册码算法： 在ds:[0+0x403087]数据段中存放着一个固定的值&quot;EJDACBBTACGIDFNG&quot;，这个值是注册码的雏形 算法首先对我们输入的第一个框的值进行格式化和过滤，规则经分析后总结如下： 如果值在0-20，那么赋予固定值&quot;F&quot;； 如果值在21-3A,那么这个值加上0x20； 如果值在3B-40，那么赋予固定值&quot;G&quot;； 如果值在41-5A，那么不用处理； 如果值在5B-60，那么赋予固定值&quot;S&quot;； 如果值在61-7A，那么这个值减去0x20； 如果值在7B及以上，那么赋予固定值&quot;G&quot;； 然后依次将这些值赋给ds:[0+0x403087]的偶数索引，比如我们输入的值是&quot;AAAAAAAA&quot;，则有： &quot;EJDACBBTACGIDFNG&quot; =&gt; &quot;AJAAABATACAIAFAG&quot; 接下来： edx = ds:[0+0x403087]的每个字符的ASCII值的总和 eax = 输入的第一个框的值的长度 * 0xFF edx = eax * edx edx = edx xor 0xACEBDFAB(这个是固定的) edx进行bswap，也就是第一个字节跟第四个字节交换，第二个字节和第三个字节交换，比如&quot;AFDAFCBA&quot; =&gt; &quot;BAFCDAAF&quot; 检验edx的每个位的ASCII值是否小于0x3A,如果是,加上0x11 然后将edx的每一位替换ds:[0+0x403087]的奇数索引 比如&quot;AJAAABATACAIAFAG&quot; =&gt; &quot;ABAAAFACADAAAAAF&quot; 将这个值和第二个框输入的值进行比较，比较规则如下： 如果是偶数索引，要求相等； 如果是奇数索引，那么对应的第二个框的那一位的ASCII值要大5； 思路理清了，接下来就是写个注册机了，注册机源代码在这里，用的易语言写的，运行如图： 拿这个去尝试： 爆破版的这里就不放了，就是改几个关键跳转的事情","path":"2016/11/07/某crackme破解/","date":"11-07","excerpt":"这是一次逆向的练习记录"},{"title":"记一次小软件脱壳","text":"记一次逆向老软件的经历 目标： 跑跑排行榜1.9.exe界面： 首先用PEID查壳，得知是tELock v0.98的壳: 首先，愉快地打开OD: 直接F9，到第一次异常发生的地方:可以看到上面有个pushad，一开始是打算用esp定律的，无奈这方法不管用，程序直接跑飞(事实上还是可以用到esp的)，跑飞点在下面的这句​ 0042C001 F9 call 跑跑排行.0042C009 此时可以选择单步进入，然后单步跟踪，但是过程很复杂，所以这里不采用单步跟踪的思路，用追踪异常的方法：在第一次F9之后，到了第一个异常点，这时候我们shift+f9，就是忽略异常执行，然后会停在下一个异常点，我们不断重复此步骤，最终到程序执行为止。不过事实上，这个程序在到下面这个地方后，再shift+f9就飞到了系统领空了，并且这个领空用alt+f9是出不来的，所以我认为这个地方是最后一个异常点(说来奇怪，我在这个异常点shift+f9居然还是在这个地方，再按一次才跑到系统领空)： 查看此时堆栈段情况： 易知0042CDF4处理这个异常的函数，那么在这个地方下断点，然后shift+f9过掉它： 然后就是漫长的单步，最后到了本次脱壳的又一个关键点： 如图所示，这个jmp跳转很大，可能是OEP，第一次我试着跳了，结果发现是个死循环，出不去的，于是我判断这个跳转是不能跳的，那么尝试f4到下面： 怎么有种似曾相识的感觉QAQ，这不是刚才的那个异常点么，再看下堆栈，SE处理程序是0042D7FD，哦，怪不得我刚才第一次在0042D819处shift+f9还是这里，这里应该是发生了两次异常，而且处理异常的函数是不同的，那么我们在0042D7FD下断点，shift+f9再次绕过这个异常，然后经过一系列的单步，到了OEP跳转点： 愉快的f8到了OEP，妥妥的VC++6.0程序： 然后就是脱壳了，这里用OD的脱壳方法是不行的，因为有很多指针是没有修复的，所以先上LORD PE转存，然后用Import REC修复： Import REC先用tElock v0.98 的3级追踪修复一堆指针，剩余的几个反汇编看了下，没什么用，就是垃圾指针，所以剪切掉： dump掉，再用PEID查壳： 完成。","path":"2016/10/31/脱壳练习1/","date":"10-31","excerpt":"记一次逆向老软件的经历"},{"title":"javascript函数化构造器","text":"javascript是基于原型继承而不是基于类继承的(至少在ES6之前是这样的。。。)，javascript对于继承这方面很模糊，它提供了原型的继承方式，却又提供了”伪类”的写法，比如下面这样： var Father = function() { this.nickname = &apos;粑粑&apos;; this.say = function() { return &apos;我是老爸&apos;; }; this.statu = function() { return &apos;我的地位是第一层&apos;; } } //声明一个伪类,通过prototype继承父类 var Children = function() { } Children.prototype = new Father(); Children.prototype.nickname = &apos;儿子&apos;; Children.prototype.say = function() { return &apos;我是儿子&apos;; } Children.prototype.statu = function() { return &apos;我的地位是第三层&apos;; } var child = new Children(); child.nickname //儿子 child.say() //我是儿子 child.statu() //我的地位是第三层 尽管我们用’伪类’的方式完成了继承，但是我们并不是用抽象的方式描述这个继承关系的，而是用了具体的，公开的方式去写继承，这种方式对于代码的安全性来说是不友好的，容易被攻击者篡改，代码维护方面也有问题，而且，使用实例必须要通过new去执行，如果没有new，结果会完全不同，变成了调用一个函数，意思就完全不同了。 所以，根据以上的情况，一个解决方案是我们不要用new这种模棱两可的方式，而是用函数化构造器，那函数化构造器又是怎么写的?这里给出一个通用的代码格式： var constructor = function(spec,my) { var that = {}; //这里可用任何能产生对象的方法,包括Ojbect.create(),new Object()之类的方法 //my作为一个共享的容器，自上而下传入，自下而上构造 my = my || {}; my.public = value; //spec作为一些配置的信息，里面包含了构造的对象需要的属性或者方法 that.example = spec.example; //然后就是对象自己构造属性或方法了 that.someProperty = function() { .... } //或者，为了更安全的着想，我们分两步构造 //这样是为了不破坏我们原来构造的方法或者属性 var someProperty = function() { .... } this.someProperty = someProperty; return that; } 这种方式关键有利于属性方法的隐藏，有利于安全，并且可以用函数式的方法去写。 ​","path":"2016/06/07/javascript函数化构造器/","date":"06-07","excerpt":"javascript是基于原型继承而不是基于类继承的(至少在ES6之前是这样的。。。)，javascript对于继承这方面很模糊，它提供了原型的继承方式，却又提供了”伪类”的写法，比如下面这样："},{"title":"《AngularJS深度剖析与最佳实践》学习笔记（二）","text":"测试展示文段 controller as的学习 在之前这本书给出的代码中,有很多次看到这样的代码: controller:controller as vm ..... angular.module(&apos;MyApp&apos;).controller(&apos;demoController&apos;,function() { var vm = this; //这里配置vm的各种属性; vm.title = &apos;Angular&apos;; .... }); 事实上,这是Angular1.2版本后推出的语法糖,我们平常写controller,一般是通过$scope来绑定变量,然后在模板中调用$scope的属性去渲染模板;类似的代码如下: angular.module(&apos;MyApp&apos;).controller(&apos;demoController&apos;,function($scope) { $scope.title = &apos;Angular&apos;; //各种配置数据逻辑 .... }); controller as的出现,使得controller不用再注入$scope服务,controller变得更加接近javascript对象,满足了喜好POJO的人的需求;下面是controller as在指令和模板中的运用的一个例子: &lt;div ng-app=&apos;MyApp&apos; ng-controller=&apos;exampleController as Demo&apos;&gt; name:{{Demo.title}} &lt;/div&gt; ... angular.module(&apos;MyApp&apos;).controller(&apos;exampleController&apos;,function() { this.title = &apos;Angular&apos;; }); 打开界面,我们可以看到name:Angular,那么,这个是怎么实现的?书上给出了Angular中controller as的部分实现源码:​ controllerInstance = $controller(controller,local); //controller即为我们上下文环境的controller,由$controller产生对应的controller实例对象 …. //如果指令as后面指定了名称 if(directive.controlleras) { //将controller实例对象赋予到$scope对应名称的属性上 local.$scope[directive.controlleras] = controllerInstance; } 上边的注释是我根据自己的理解加的,从源码可以看出,controller as实际上就是将controller实例赋值到$scope上的一个属性中,属性名即为我们指定的名称,这样做的话,我们便可以在不注入$scope服务的情况下将数据绑定到模板上,只不过媒介变为了controller,controller等于变成了我们常用的javascript对象了。 那么,controller as这货可以用在哪些地方呢? 指令上: 一般的代码形式是: angular.module(&apos;MyApp&apos;).directive(&apos;directiveAs&apos;,function() { return { restrict: &apos;EA&apos;, template: &apos;&lt;div&gt;&lt;/div&gt;&apos;, controller: &apos;DemoController&apos;, controllerAs: &apos;vm&apos; }; }); 这样有个问题,很明显上面的格式是组件型指令的格式,组件型指令我们一般用独立作用域,即添加scope:{},但是scope:{}的属性是不会绑定到我们指定的vm的,它会绑定到$scope上,而我们期望的是: $scope-&gt;$scope.vm-&gt;scope:{}绑定的属性,这个问题其实很好解决,只需在上面添加bindToController:true就行了。 路由上: 比如,我们可以在ui-router这样指定: $stateProvider.state(&apos;demo&apos;,{ url: &apos;....&apos;, templateUrl: &apos;....&apos;, controller: &apos;demoController as vm&apos; }); 据说,用controller as,然后在模板中用$scope的属性去访问controller实例的数据可以有效避免“javascript原型链继承对于值类型的坑”(书上所说,会在后面章节提到),我并不是很理解,等我看到后面一点章节再提提这个东西吧,现在还不是很懂这个坑是什么坑,controller as又是怎么有效避免的。","path":"2016/05/16/《AngularJS深度剖析与最佳实践》学习笔记（二）/","date":"05-16","excerpt":"测试展示文段"},{"title":"《AngularJS深度剖析与最佳实践》学习笔记（一）","text":"看了三章之后才想到我应该写一些笔记来加深印象和理解,所以写的顺序会有点乱，到时再进行重新排版 指令: Angular2.0将指令分为组件型指令和装饰器型指令,虽然是2.0的标准,但是这个分法同样适用于Angular1.0: 组件型指令: 组件型指令的一般格式如下: angular.module(&apos;myApp&apos;).directive(&apos;conponent&apos;,function(){ return { restrict: &quot;EA&quot;, scope: { count:1 }, templateUrl: &apos;partials/conponent.html&apos;, controller: function($scope){ //相关业务逻辑操作 } .... } }); 组件型指令的特点可以概括为: 高内聚低耦合 这种指令通常作为页面或者模板的一个组件,有自己的独立作用域,形成自己的业务逻辑,与外部模板页面的耦合性低,即使去掉这个指令,也不会对全局有影响，这样带来的好处是:代码的可维护性和复用性; 我们搭建的组件可以用在其他的页面上,例如,我们做了个登录框的组件: &lt;login-form username=&apos;form.username&apos; email=&quot;form.email&apos; password=&apos;form.password&apos;&gt;&lt;/login-form&gt; 自定义指令: angular.module(&apos;myApp&apos;).directive(&apos;loginForm&apos;,function(){ return { restrict: &apos;EA&apos;, scope: { username: &apos;=&apos;, email: &apos;=&apos;, password: &apos;=&apos; }, templateUrl: &apos;partials/login.html&apos;, controller: function($scope,$http) { //业务逻辑处理 $http({ method:&quot;POST&quot; data: &apos;&apos; }).success(function(data) { //... }); }, } }); 这样,我们自定义的登录组件骨架基本完成,只要想在页面进行引用,就在模板页面嵌入对应的元素即可。 组件型指令是一个小型的,内聚的,自封装的整体,其主要的目的应是内容信息的展示,应该尽量避免使用link(初学者写自定义指令一般都会用到这个,并且在link阶段加入典型的jQuery代码,再用scope.$apply()通知ViewModel进行脏检查。。。不要问我为什么知道), 将业务逻辑写在controller中,当然,controller不要太脏,应该将表现层逻辑的代码用服务封装y,与业务层逻辑代码分离,保持controller的干净; restrict restrict中我们设为’EA’,retrict有四种情况:E(元素),A(属性),M(注释),C(类),通常我们在实战中用到比较多的是E和A, 如果我们的定位为组件型指令而不是装饰器型指令,我们可以只用E,用A是为了与IE8兼容,因为IE8对于新元素必须要通过document.createElement去实现。。。,当然,不想兼容IE8就略过这点。。。 scope scope在指令中有三种情况: scope = undefined || false: 这种情况不需要创建作用域,直接使用父作用域的数据,如果节点中有创建了新作用域或独立作用域的指令,可以引用对应的作用域; scope = true: 这种情况则是表示需要一个新作用域,可以共享节点的新作用域,如果没有,则自己创建一个新作用域; scope = 哈希对象: 这种则是创建独立作用域,只通过某些固定的接口与外部作用域进行交互,实现了与外部作用域的隔离,这种情况我们即可以从父作用域获取我们想要的属性,又能避免引用到父作用域的相关属性; 当scope为哈希对象时,我们通常这样写: scope: { count: &apos;@&apos;, count1: &apos;=&apos;, count2: &apos;&amp;&apos; } @表示的是引用字符串,’=’表示的是引用父作用域的变量,’&amp;’表示的是引用父作用域的方法; 装饰器型指令: 装饰器型指令的特点是: 给对应节点增添dom行为,增强view与model的同步; 不像组件型指令是作为一个整体,装饰器型指令的定位是作为功能性的连接器，增强相应的表现层和业务层逻辑,一般的定义方式如下: angular.module(&apos;myApp&apos;).directive(&apos;decorator&apos;,function() { return { restrict: &apos;EA&apos;, link: function(scope,elm,attrs) { //..... } }; }); 当然,上面的定义是最基本的,后面还要讲到一些关于指令的重要的东西,这里就先这样用。 装饰器型指令中,由于其定位关系,不像组件型指令,它并不需要创建新作用域或是独立作用域(当然如果你想创建也可以),那么,如果我们没有创建作用域,那我们是如何像独立作用域那样拿到赋予的值呢? 回到我们上面的代码,我们可以看到link参数有个attrs,嗯,这个就是我们获取数据的关键,看下面的代码: &lt;login-form username=&apos;feitou&apos; email=&apos;form.email&apos; password=&apos;form.password&apos; submit=&apos;submit(time)&apos;&gt;&lt;/login-form&gt; 实际上不会写这样的指令,在这里只是作为说明使用———username对应的是固定字符串feitou,我们可以在link阶段直接用attrs.username获取这个字符串,父作用域的值则通过scope.$eval(attrs.email)获取,scope.$eval()负责计算表达式的值,而父作用域的方法呢?由于方法也是父作用域的一部分,所以我们依旧用scope.$eval(),但是要这样用(以上面为例):scope.$eval(attrs.submit&#39;,{ time:3 }),第二个参数就是传入方法的参数,用对象来配置,并且名字要对应相同(与view上的方法参数名对应相同),这样,我们讲解了没有作用域如何去获取对应的数据了; angular内置的大多数指令如ng-hide,ng-show这样都是装饰器型的指令,就是增强html的功能,将view进行进一步的分离,在实战中,我们避免不了要写自定义指令,这个时候,我们要考虑的,是我们这个指令的定位是什么,根据我们的定位去选择对应的指令方式,代码结构才能不断优化,指令的目的之一,就是为了优化我们的代码结构。","path":"2016/05/12/《AngularJS深度剖析与最佳实践》学习笔记（一）/","date":"05-12","excerpt":"看了三章之后才想到我应该写一些笔记来加深印象和理解,所以写的顺序会有点乱，到时再进行重新排版"},{"title":"新手玩云服务器","text":"在腾讯云平台进行学生认证后,每个月都有64块的优惠券到账,最低配的云主机只需要65块,换言之,一个月只要1块钱就能租到云主机,还是挺爽的,今天花了点时间配置云服务器(我不会说我是带着电脑上课并且在玩这个的Q^Q),总结一下配置的基本步骤吧(其实很多我也不是很懂) 0X00:连接到云服务器：我的电脑系统是win7,而且买的是CentOS的,所以这里只说本地windows下怎么配置CentOS云服务器: 腾讯官方文档给出的是用SecureCRT、putty来登录,个人觉得xshell可以完爆这两货。。。xshell下载地址 打开xshell,新建服务器连接,如下图所示: 名称随你喜欢,填个有意义又简单的最好~ 主机填写云主机的公网IP 端口号默认为22 说明随你喜欢,跟名称的说法一样~ 进行连接,会提示你输入用户名,腾讯云主机的主机管理用户名如下所示: SUSE/CentOS/Debian：root Windows：Administrator ubuntu：ubuntu 密码的话,在你购买的订单中是有初始密码的,最好进行密码重置:进入腾讯云中心,进入管理中心,点击云主机的更多进行密码重置: 注意！要先将云主机关机才能重置密码 在你下订单后购买到云主机后,可以将云主机私钥导入到你的电脑中,这个是建立连接的关键点击浏览-&gt;文件,选择你的私钥,下面密码填你设置的密码,点击确定,进行连接,看到类似下图,说明连接成功~ 0x01进行云服务器的数据盘相关操作:数据盘信息:运行以下命令可以查看数据盘相关信息,包括数据盘大小,被占用的空间以及剩余空间等等 # fdisk -l # df -h 数据盘分区:官方文档说是按以下命令来进行数据盘分区: # fdisk /dev/xvdbs 嗯,我试了下这个命令,结果给我提示这个: Unable to open /dev/xvdb 查了下,发现新的CentOS系统应该按这样的命令去分区: # fdisk /dev/vdbs 执行完这个命令以后,依次执行以下命令: n 新建分区 p 进行主分区 1 使用第一个主分区 Enter Enter 这里的两次Enter都是选择默认配置 wq 保存并退出 此时再输入fdisk -l如果看到/dev/vdbs和/dev/vdal,则说明分区成功当然,分区可以创建多个,具体看你喜欢,不过要谨慎! 格式化新分区:格式化新分区是为了后面能在系统上安装软件以及进行相关必要的操作: mke2fs、mkfs.ext2、mkfs.ext3、mkfs.ext4 Windows下的文件系统有Fat32、NTFS，CentOS使用的文件系统为ext。之前CentOS5版本使用ext3作为默认的文件系统，而CentOS6使用ext4作为默认的文件系统,我的是CentOS6.5的,当然是ext4啦~ mkfs.ext4 /dev/vdb1 挂载新分区:依旧给出代码(官方文档给出的): # mkdir /mydata 创建mydata目录 # mount /dev/xvdb1 /mydata 手动挂载新分区 再用df -h查看,如果看到Filesystem有/dev/vdb1和/dev/vda1的话就说明挂载新分区成功~ 添加分区信息(就是保存你的挂载):这个操作是为了让主机在重启或关机后开机都能进行自动挂载,免得你每次手动挂载,这里按照官方文档给出的命令就行了~ echo &apos;/dev/xvdb1 /mydata ext3 defaults 0 0&apos; &gt;&gt; /etc/fstab 添加命令分区信息 cat /etc/fstab 查看是否添加成功 0x02在云服务器进行软件安装:腾讯云服务器提供了yum下载源,即我们可以通过yum在云服务器中下载东西,很简单的命令就可以安装: # yum install mysql mysql-server nginx php php-fpm 按y确定后进行安装,出现Complete即安装成功 安装完软件后,我们可以查看软件相关信息: # rpm -ql nginx 查看安装目录 # rpm -q nginx 查看安装版本 0x03云服务器环境配置:按照官方文档,我们来配置nginx和php:配置nginx:我们先启动nginx服务先 # service nginx start 启动完后访问公网IP,如果能访问到,说明nginx服务启动成功 配置php:同样启动php服务先 # service php-fpm start 查看php-fpm默认配置​ # cat /etc/php-fpm.d/www.conf |grep -i &apos;listen =&apos; ​如果看到listen = 127.0.0.1:9000,说明监听端口为9000,我们要将php解析的请求全部转发到127.0.0.1:9000 修改nginx配置:​ # vim /etc/nginx/conf.d/default.conf 按官方文档的修改方式来: server { listen 80; root /usr/share/nginx/html; server_name localhost; #charset koi8-r; #access_log /var/log/nginx/log/host.access.log main; location / { index index.html index.htm; } #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html { root /usr/share/nginx/html; } # proxy the PHP scripts to Apache listening on 127.0.0.1:80 # # location ~ \\.php$ { # proxy_pass http://127.0.0.1; # } # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # location ~ \\.php$ { fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; include fastcgi_params; } # deny access to .htaccess files, if Apache&apos;s document root # concurs with nginx&apos;s one # # location ~ /\\.ht { # deny all; # } } 修改完后按ESC,然后：wq，保存修改 注意！要加:,不然是无法输的,我早上因为这个弄惨了QAQ然后重启nginx服务 # service nginx restart 验证配置: # vim /usr/share/nginx/html/index.php php的内容配置: &lt;?php echo &quot;&lt;title&gt;Test Page&lt;/title&gt;&quot;; echo &quot;hello world&quot;; ?&gt; 接下来访问公网IP/index.php,看到helloworld就说明环境配置成功了 0x04部署代码到云服务器中:一般我们要把代码放到云服务器中,就要通过FTP上传来放,所以我们首先要在云服务器配置FTP服务,在腾讯云上可以直接用yum来装vsftpd配置FTP: # yum install vsftpd 然后是配置vsftpd # vim /etc/vsftpd/vsftpd.conf 只要将下图的这些选项都搞好就行了,如果你要取消匿名登录使用ftp服务,那么要将vsftpd.conf中的anonymous_enable=YES注释掉或者改为anonymous_enable=NO local_enable=YES write_enable=YES local_umask=022 anon_upload_enable=YES //anon的这三个是要你去手动取消注释的,其他的默认都有了 anon_mkdir_write_enable=YES anon_umask=022 dirmessage_enable=YES xferlog_enable=YES connect_from_port_20=YES xferlog_std_format=YES listen=YES pam_service_name=vsftpd userlist_enable=YES tcp_wrappers=YES 你要如何知道这个配置呢?可以通过以下代码进行读取,经过前面的配置我们也能猜到是要用cat这个命令了: # cat /etc/vsftpd/vsftpd.conf |grep ^[^#] 配置了FTP服务后,我们要建立FTP用户名和密码,这是我们要建立FTP连接上传文件要用到的登录用户名和密码,​建立用户名: # useradd -d /home/megiki -s /sbin/nologin megiki megiki是我ftp的用户名,所以将你的用户名替换掉megiki就行了 给对应用户设置密码: # passwd megiki 这里同样替换你的ftp用户名 注意!,这里会要你输入密码,并且重新输入,而你的输入是看不到的,所以你运行了上述命令后直接输入密码按Enter，然后再输入一次密码按Enter就行了,密码不要输错接下来就是修改pam文件了,修改这个文件的目的是为了真正让我们设置的ftp用户能连接到ftp服务器: # vim /etc/pam.d/vsftpd 这里按官方文档的修改方式: auth required /lib64/security/pam_listfile.so item=user sense=deny file=/etc/ftpusers onerr=succeed auth required /lib64/security/pam_unix.so shadow nullok auth required /lib64/security/pam_shells.so account required /lib64/security/pam_unix.so session required /lib64/security/pam_unix.so 修改完后确认: # cat /etc/pam.d/vsftpd #%PAM-1.0 下面这个是你修改后产生的结果: auth required /lib64/security/pam_listfile.so item=user sense=deny file=/etc/ftpusers onerr=succeed auth required /lib64/security/pam_unix.so shadow nullok auth required /lib64/security/pam_shells.so account required /lib64/security/pam_unix.so session required /lib64/security/pam_unix.so 事实上,我在配置的时候发现还是和官方文档的说明有很大差别的,这个是我修改之前的样子: 这是我修改之后的样子: 如果你在按我上面所说的方法配置,遇到了pam文件不一样的问题,也可以按我上面这两个图来配置(注意把里面的ftp用户名改为你的) 这样云服务器的ftp服务算是完成了,我们可以用FTP上传工具去上传我们的代码了,这里我们用官网说的FileZilla进行FTP上传,我们先建立一个新站点,以后直接连接这个站点就行了~ 主机:你的公网IP 端口:用21端口 登录类型:一般 用户名:填写你设置的FTP用户 密码:同上 然后我们在/usr/share/nginx/html这个目录下进行代码文件的传输,这样就把我们的代码部署到云服务器上了,比如你把text.html传到这个目录下,然后我们访问你的公网IP/text.html,内容就是你上传的text.html 这个说一个问题啊,可能我们按上面的步骤进行FTP传输时可能一个都传输不了,这时你可以查看/usr/share/nginx/html这个文件的文件权限,如果是755,说明公共组是不能进行FTP上传的,这时候,我们可以在xshell5上进行权限的修改: # chmod -R 777 /usr/share/nginx/html 将权限改为777,然后公共组就拥有了写入的功能,这时可以FTP传输了 当然,如果你觉得这样不安全(事实上是确实有些不安全的),你可以用git的方式(简单又粗暴),用git clone的方式进行传输,你可以把你上传的代码放在你的github或者coding的私有库上,再传输给你的服务器,具体怎么做这里就不说了(如果你熟悉git操作的话你应该懂的,不懂git为何物的话请戳这里) 0x05结尾：好了,关于云服务器的配置就说到这里(好像写得有些太长了，其实我个人也不喜欢太长的博客,太长的博客我基本都没有认真看完的QAQ),这个只是新手级别的配置,云服务器是可以让你玩年系列的东西,特别是你在实际项目中的运用,有时间我会继续研究云服务器这个东西的(顺带研究nginx这个东西) 玩这个东西花了我一早上的时间,早上的汇编和汇编实验课我都在干我自己的(这里说一句,真的,大学那些计算机的课真是纯理论课,没有什么实际意义,老师讲的又慢,硬是能把20分钟的东西用两节课来讲。。。),这段时间我报名了’校园杯’,截止日期是4月23日,也没什么时间给我浪了,所以关于云服务器的探索就到这里,等我搞完这个比赛后再折腾这些(话说校园杯过了后还有CTF,挑战杯QAQ)。","path":"2016/04/08/新手玩云服务器/","date":"04-08","excerpt":"在腾讯云平台进行学生认证后,每个月都有64块的优惠券到账,最低配的云主机只需要65块,换言之,一个月只要1块钱就能租到云主机,还是挺爽的,今天花了点时间配置云服务器(我不会说我是带着电脑上课并且在玩这个的Q^Q),总结一下配置的基本步骤吧(其实很多我也不是很懂)"},{"title":"HEXO解决Google字库链接缓慢问题","text":"就在刚刚,我发现我的博客上不去了，hexo s开启本地端口也上不去,后来排查了下,是fonts.googleapis的锅QAQ 开启开发者工具监听network,访问博客可以看到一条失败的记录,记录指向的url如下: http://fonts.googleapis.com/css?family=Lato:300,400,700,400italic&amp;subset=latin,latin-ext 哦,fonts.googleapis,Google在大陆是被墙掉的,所以访问慢也很正常(话说之前我的博客应该也有这个link,为什么之前都能正常访问),由于我的主题是Next主题,所以我在以下目录找到了代码的关键点: D:\\HEXO\\themes\\next\\layout\\_partials\\head.swig 在head.swig下找到了这段代码: &lt;link href=&quot;http://fonts.googleapis.com/css?family=Lato:300,400,700,400italic&amp;subset=latin,latin-ext&quot;/&gt; 我把中间那段代码删去后就能访问了。话说博客还真是学习的好东西啊","path":"2016/03/09/HEXO解决Google字库链接缓慢问题/","date":"03-09","excerpt":"就在刚刚,我发现我的博客上不去了，hexo s开启本地端口也上不去,后来排查了下,是fonts.googleapis的锅QAQ"},{"title":"Python文档之Tkinter","text":"最近打算做一个python的音乐播放器,GUI采用python的Tkinter去写(虽然用python去写GUI是很蛋疼的QAQ),但是网上关于Tkinter模块的说明都是英文的,还不如直接去啃python文档中的Tkinter模块部分,于是乎就去啃了TKinter模块的英文文档。。。这里讲讲文档上看到一些姿势。 Setting Options:当我们创建widget时,如果我们要给widget添加相关的设置,有三种方法添加: 通过constructor来指定option通过索引来指定option通过config来指定option 举个栗子: 这三种方法都可以设置 self.button = Tk.Button(bg=&apos;blue&apos;) self.button[&apos;bg&apos;]=&apos;blue&apos; self.config(bg=&apos;blue&apos;) 如果我们想要设置某些参数但又不知道怎么设置,我们可以通过config()来打印出设置的参数: print(self.button.config()) 注意!如果是有类似bg这种属性缩写的话,一般是个2-tuple,不然是个5-tuple：(来自python的官方文档) option name option name for database lookup option class for database lookup default value current value Coupling Widget Variables看到这个的时候,我感觉跟angular的MVVM模式还是挺像的,改变M会在V上反应出来,改变V的值,M的值跟随改变,某些widget(比如Entry widget)的实值可以和应用的variable相互绑定,不过要将variable赋予到widget的指定option上,这样的option包括variable,textvariable,onvalue,offvalue,value,不过python自身的variable是不支持这种格式的,要用TKinter的Variable Class及其子类产生的变量才能采用,比如StringVar,IntVar,DoubleVar或是BoolVar,这种形式的变量可以用get()和set()方法来获取和设定自身的值。这里依旧给出文档的例子: class App(Frame): def __init__(self, master=None): Frame.__init__(self, master) self.pack() self.entrythingy = Entry() self.entrythingy.pack() # 我们在这里创建了Variable Class 变量 self.contents = StringVar() # 通过set()方法设定实值 self.contents.set(&quot;this is a variable&quot;) # 将widget和Variable进行绑定 self.entrythingy[&quot;textvariable&quot;] = self.contents # 在这里我们进行了事件绑定 # &lt;Key-Return&gt;表示用户每次按回车键的事件 # 触发该事件时调用print_contents打印出Variable # 的值,同时观察是否Variable和widget进行了绑定 self.entrythingy.bind(&apos;&lt;Key-Return&gt;&apos;, self.print_contents) def print_contents(self, event): print(&quot;hi. contents of entry is now ----&gt;&quot;, self.contents.get()) 运行上述程序会发现,当我们将Entry的值修改了以后,按下回车,会打印出我们修改的值(self.contents.get()),说明widget的实值已经和Variable进行了绑定。 Bindings and Events说起GUI界面,一定会有用户事件机制,TKinter中,采用bind()方法将widget和对应的事件类型绑定在一起,形成对widget事件的监听,bind方法的定义如下: def bind(self, sequence, func, add=&apos;&apos;): sequence表示事件类型,事件类型的话可以参考这个文档 func表示对应的事件处理函数,当事件触发时调用这个函数 add在bind中要默认值’’,实际上add可取的值有’’和’+’,当add取’’的时候,对同个widget触发的同个类型的事件只能调用一个事件处理函数,比如: self.button.bind(&apos;&lt;Enter&gt;&apos;,fn1) self.button.bind(&apos;&lt;Enter&gt;&apos;,fn2) 这个时候触发事件只会调用fn2而不会两个都调用,当add取’+’的时候,则事件可以绑定多个监听器,即可以同时触发 就讲这么多了,python文档的内容只是做了个概述而没有详细地去讲,想要了解更多的同学可以去这里或是去看比较完整的文档","path":"2016/03/08/Python֮Tkinter/","date":"03-08","excerpt":"最近打算做一个python的音乐播放器,GUI采用python的Tkinter去写(虽然用python去写GUI是很蛋疼的QAQ),但是网上关于Tkinter模块的说明都是英文的,还不如直接去啃python文档中的Tkinter模块部分,于是乎就去啃了TKinter模块的英文文档。。。这里讲讲文档上看到一些姿势。"},{"title":"信息安全小知识","text":"如果你看到图片变大但是没有文字, 那么就是没有加more字段了 引言:上次写了篇关于SSL协议的博文,感觉意犹未尽,这次来讲讲其他一些信息安全的知识,大概就侃侃这些: 加密算法 摘要算法 数字签名 数字信封 加密算法:上次讲过,SSL握手协议中客户端将与服务端协商得到的共享对称密钥进行信息的加密,再用服务端给的公钥进行加密,传输给服务端,服务端用自己的私有密钥进行解密,再用对称密钥解密得到客户端传输的数据信息,这个过程中牵扯到两种加密算法: 私钥加密(对称加密) 公钥加密(非对称加密) 先讲讲私钥加密: 私钥加密的加密密钥和解密密钥是一样的,所以又称为对称加密,DES,AES加密算法就是私钥加密,要求你有正确的密钥才能解开密文,所以,在这种情况下,密钥的保存相当重要,而加密的算法被公开也不会影响数据的安全性(单单只是加密算法而没有密钥解开密文的可能性几乎为0),如果密钥被截取,那么第三方可能通过逐一尝试算法进行解密,信息很容易被第三方窃取,所以如果用的是私钥加密,那么密钥是一定要保管好的 再谈谈公钥加密: 公钥加密的加密密钥和解密密钥是不同的,所以又称其为非对称加密,这方面对应的算法有RSA非对称算法,举个例子:A有自己的私钥,B给A的公钥,B有自己的私钥,A给B的公钥,A写了一段信息,用B给的公钥进行加密,再发送给B,防止有人偷看信息,B拿到信息之后再用自己的私钥解开密文,拿到A的信息,反之,若B要发送给A信息,则只需要用A的公钥加密,A端用自己的私钥解密就行了。下图展示了公钥加密的过程: 公钥加密与私密加密各有优缺点,私钥加密只用一把密钥进行加密解密,安全性相对公钥加密要低,但是比公钥加密要快上许多,如果遇上大信息量的加密解密,私钥加密要比公钥加密快上几千倍!一般的想法是:将大信息量用私钥加密进行过加密,得到的密文比明文要小了许多,这时再用公钥加密会节省许多时间,比起只用公钥加密要快得多。 摘要算法:摘要算法是不可逆的算法,一段经过摘要算法进行加密的密文是不可能解出原本的明文的,只能通过将相同的明文进行加密才能得到相同的结果,摘要算法主要用在’数字签名’中。摘要算法的特点是,不管对于多长的明文,都可以加密成固定长度的密文,比如md5固定是32位或是16位,每一位都是16进制,常见的摘要算法包括md5,sha1,sha256。一般我们得到一段摘要算法加密的明文,可以去cmd5尝试(碰碰运气而已，有些加了盐的密文根本就找不到的,还有大部分是要付费查询的…) 数字签名:什么是数字签名?数字签名就是将消息用发送者的私钥进行加密,与原文一起进行打包传输给接收者，接收者采用发送者给的公钥进行密文解密,如果解出来的明文和原文是一样的,则证明消息是正确的没有被篡改过。在很多场合数字签名得到了使用,比如网上交易,采用数字签名可以保证网络传输的完整性,验证发送者的身份,并且发送者不可抵赖行为的发生。 数字签名采用的是公钥加密,保证数据不会被篡改,如果有第三方截取信息,用公钥对摘要进行解密,那么他是无法再生成一段摘要的,因为他拿不到原本发送者的私钥,如果他用他自己的私钥进行加密,那么他必须将他自己的公钥替换掉接收者持有的原本发送者的公钥(这并不现实,但是还是有可能的),否则,接收者用发送者的公钥进行解密,会得到不一样或是根本无法解密,也就可以断定信息被第三方动了手脚,从这一方面给来看,数字签名即保证了数据完整，又保证了消息的发送方,并且发送方是不可否认自己发过这个信息的。符合网络安全的四大要素: 信息传输的保密性、数据交换的完整性、发送信息的不可否认性、交易者身份的确定性。 从上述我们可以知道,数字签名的技术基础是公钥加密,但是公钥加密的速度是很慢的,如果发送的信息太长,那么加密解密的时间消耗会非常大,那么有什么相应的解决方法呢?——答案是我们刚才讲过的摘要算法,摘要算法产生的长度是固定的,而将明文先进行摘要,再将得到的结果进行公钥加密,接收者解密后再将原文用相同的摘要算法进行加密,如果得到的结果是一样的话,那么可以断定信息是正确的,这种方法既加快了效率,又能保证足够的安全性。 数字签名的实现方法有挺多的,比如RSA签名,这里给出两个RSA签名的实现过程图(分别为保密机制的和非保密机制的): 非保密机制的RSA签名： 保密机制的RSA签名: 数字信封:数字信封指的是:先用对称密钥对信息进行加密,加密后用非对称密钥(接收者的公钥)对对称密钥进行加密,然后将加密的密钥和加密的信息打包给接收者,这个过程既加快了速率,又保证了安全性,如果你看过上面的保密机制的RSA签名的话,你就会发现保密机制的RSA签名就用了数字信封,而且现在的数字证书也用到了这种方法。","path":"2016/03/04/信息安全小知识/","date":"03-04","excerpt":"如果你看到图片变大但是没有文字, 那么就是没有加more字段了"},{"title":"浅析SSL协议","text":"前几天教务系统选课,发现教务系统已经开放了https的链接,终于学校方面也开始用SSL来保证传输的安全性了,这里稍微讲讲一下SSL协议吧~ SSL(Secure Sockets Layer)又称安全套接字层,是一种调用各种加密方法,保证网络通信安全的策略,我们通常访问网站用的是http协议传输,http协议是明文传输,没有任何加密,所以数据信息很容易被中间人窃听或是劫持,数据的安全性得不到保证,而https则是采用了SSL协议,将传输的数据进行加密,这样就算数据被中间人劫持,也不容易被破解获取,所以现在很多企业都在用https,甚至许多反向代理服务器都有SSL功能。 SSL协议包括两个协议: SSL记录层协议: SSL记录层协议提供了对数据封装,压缩,加密的基本支持,建立在TCP协议的基础之上,下面给出SSL记录层协议过程实现图: SSL记录层协议过程的实现:将数据明文切分成多个切片,将每个切片进行压缩(用协商的压缩算法进行压缩),将每个压缩包分别进行MAC计算,得到MAC值,将压缩包和MAC添加在一起,最后添加SSL协议头进行包装。 SSL握手层协议: 这个协议是建立在SSL记录层协议之上的,通过握手层协议,服务端和客户机进行相应的操作,包括身份验证,协商加密算法,协商对称加密密钥。 CLient hello阶段:客户端向服务端传输下列的参数: 客户端支持的TLS/SSL版本号:如TLS1.0,SSL2; 客户端产生的随机数; 客户端支持的加密算法,如RSA(公钥加密); 客户端支持的压缩算法; 服务端接受客户端的参数后,也将一系列参数回传给客户端: Server hello阶段:服务端给客户端回传以下参数: 服务端采用的SSL/TLS版本号; 服务端产生的随机数; 服务端提供的加密算法; 服务端提供的压缩算法; 服务端提供的数字证书; 这里稍微提一下,如果是在金融机构这类有认证用户的企业,会要求用户提供对应的客户端证书,这种类似于工商银行的U盾,用USBkey进行用户身份认证,确保发送者是认证客户。 客户端再次回应: pre-master key 第三个随机数,用于生成客户端和服务端共享的对称密钥; 对应的编码,告诉服务端客户端的握手过程已经结束; 这里客户端的握手过程已经结束,等待服务端生成共享密钥; 服务端回应: 一个共享的用于对称加密的对称密钥; 编码,告诉客户端服务端的握手过程已经结束; 客户端将使用共享的对称密钥对信息进行加密,将加密后的密文用服务端提供的公钥进行二次加密,传输给服务端,服务端用自己的私钥进行解密,再用对称公钥进行解密,得到最终客户端传输的数据信息。 看完这个过程,我们可能会有几个问题: 为何服务端给的公钥要用数字证书进行包装? 如果直接用公钥,那么公钥很可能被三方进行篡改,换成第三方自己的公钥, 拦截客户用该公钥加密传输的信息进行私钥解密即可窃取用户信息,采用数字证书包装,可保证数据的确定性和完整性,如果第三方篡改了数字证书,浏览器会判断这个证书是不受信任的,换言之,用户也就不会将信息进行传输了。 既然私钥是服务端才拥有的,客户端为何不直接用公钥加密传输给服务端? 如果直接用公钥加密(非对称加密)就意味着要对客户端的所有信息量进行加密,如果客户端的信息量很大,那么这个加密过程会耗费相当长的时间,加之服务端解密所耗费的时间,这个过程是难以想象的,而密钥加密(对称加密)的速度要比公钥加密快得多,有的情况甚至快几千倍,先采用密钥加密明文,得到的密文会比原明文缩小了许多,这时用公钥加密会节省很多的时间,而且安全性有过之而无不及。 网站使用SSL协议,保证了数据传输的完整性,安全性,发送者的不可否认性以及发送者的确定性,SSL协议广泛地用在用户登录,网上交易,电子邮件传输等等多个与用户数据相关的业务上,能够确保用户数据不会被轻易地窃取。 以上是自己对SSL协议的一点见解,可能有很多的地方讲得不是很严谨(甚至有些偏差QAQ),希望各位看官请多见谅QAQ PS:SSL/TLS运行机制概述,这个讲得很好,作者是阮一峰,他的博客写得很好,大家有兴趣的可以去看看他的博客。 由于网络协议方面的东西我不太清楚,而如果要成为一名web工程师,了解http协议,Tcp/Ip协议这些跟计算机网络相关的东西是必要的,然而现在课还是蛮多的,只能利用摸鱼的时间去学习了,以后有时间会写一些关于网络协议方面的博文吧~","path":"2016/03/03/浅析SSL协议/","date":"03-03","excerpt":"前几天教务系统选课,发现教务系统已经开放了https的链接,终于学校方面也开始用SSL来保证传输的安全性了,这里稍微讲讲一下SSL协议吧~ SSL(Secure Sockets Layer)又称安全套接字层,是一种调用各种加密方法,保证网络通信安全的策略,我们通常访问网站用的是http协议传输,http协议是明文传输,没有任何加密,所以数据信息很容易被中间人窃听或是劫持,数据的安全性得不到保证,而https则是采用了SSL协议,将传输的数据进行加密,这样就算数据被中间人劫持,也不容易被破解获取,所以现在很多企业都在用https,甚至许多反向代理服务器都有SSL功能。 SSL协议包括两个协议:"},{"title":"用hexo搭建博客","text":"昨天用hexo搭建好了静态博客,途中经历了一些曲折,在这里分享我搭建博客的过程经验,也算给想搭建博客的新人一个引导吧! 前期准备: 安装Node.js: Node.js下载 根据你的系统下对应的node.js版本，例如我的系统是win7 64位的，那么我就下Windows版本的64-bit版本 安装git: Git下载 同样下好对应系统的git版本 如果安装好了Node.js和git,我们可以开始安装hexo了~ 安装hexo随便找个什么地方右键git bush here 然后执行下面的指令: npm install hexo -g 这里是全局安装hexo,这个过程有点慢(你懂的),建议翻墙安装(我是翻墙安装的,速度贼快。。。) 初始化博客安装完hexo后,我们得建个文件夹来存放网站,例如我们可以在D:\\HEXO放我们的网站,假定你已经建了这个文件夹，那么，接下来我们要做的就是在该目录下右键git bush here，然后执行以下指令: hexo init 生成博客初始化博客之后博客目录下会产生一些配置文件和模板文件，现在就要利用这些模板文件来生成我们的静态博客文件，通过下面这条命令就可以生成我们的博客 hexo generate 执行完命令之后，在博客目录下会产生一个public文件夹，这里面存放的就是我们的博客静态文件。 本地部署生成网站后,我们还需现在本地测试一下我们的网站是否搭建成功,运行以下指令就可以将网站部署在我们的本地服务器上: hexo server 现在我们打开浏览器访问http://localhost:4000 就可以看到我们的博客了~,是不是有点小激动咧~ 部署到GitHub虽然成功在我们的本地服务器上运行了,但是只能我们自己看到,别人是看不到的,要想让别人也能看到,我们就得把它部署到github上而不是我们的本地服务器上 注册github账号(注册账号这种事不用多说了) 新建一个repository，repository的格式应该像下面的格式: ZEROKISEKI.github.io 你只要将你的名字替换掉对应的名字就行了(注:我的github账号是ZEROKISEKI) 配置_config.yml,就是配置hexo的github地址,这样才能把我们的hexo部署到github上去，我们先找到下面这段代码: Deployment## Docs: http://hexo.io/docs/deployment.html deploy: type: 我们将这段代码替换为: # Deployment ## Docs: http://hexo.io/docs/deployment.html deploy: type: git repository: https://github.com/用户名/用户名.github.io.git branch: master 貌似说现在新版的hexo的type不能写为github而要写为git(反正我用github就狂报一对错误) 4.通过上述步骤后，我们依次输入以下指令: hexo g hexo d 其中,hexo d会要求你输入github的账号和密码,如果配置了ssh-key的话可以不用输入 5.访问http://用户名.github.com或者http://用户名.github.io，我们就可以看到浏览器效果了,博客成功部署在我们的github上面了~ 配置博客我们可以通过修改_config.yml上的相关参数来进行博客一些基本信息的配置，比如我们可以修改博客的作者名字和博客标题: # Site title: 特别任务支援科 //标题 subtitle: //副标题 description: //描述内容 author: 班宁斯 //作者 language: zh-CN //语言 更多的一些情况请大家查看官方文档 写文章先创建一篇文章,执行以下指令即可完成文章的创建: hexo new 我的第一篇博文 执行完后,我们会发现在source/_post目录下出先了我的第一篇博文.md这个文件,我们可以用markdown编辑器对其进行编辑,不会用markdown的看这里,windows系统下较好用的编辑器有markdownPad2,或者你也可以用在线的编辑器 写完博客后,不要忘记执行下面的指令: hexo g hexo d hexo g将修改的结果保存,hexo d将修改同步到github上去,不然你改动了,访问你的站点也没什么变化的QAQ 好了，关于hexo搭建博客的内容就写到这里了,hexo自带的主题其实并不怎么好看,你可以在这里下载你觉得好的主题。","path":"2015/12/20/用hexo搭建博客/","date":"12-20","excerpt":"昨天用hexo搭建好了静态博客,途中经历了一些曲折,在这里分享我搭建博客的过程经验,也算给想搭建博客的新人一个引导吧!"}]}