{"pages":[{"title":"404","text":"","path":"404/index.html","date":"12-30","excerpt":""},{"title":"关于我","text":"标签: ACG控 | falcom(法老控) | 幼刀控柚子控 | 八月控 | 代码控 狡兔三窟, 换过几次blog, 最终在godday买了个.moe域名新的blog, 新的开始。","path":"about/index.html","date":"12-30","excerpt":""},{"title":"分类","text":"","path":"categories/index.html","date":"12-30","excerpt":""},{"title":"留言板","text":"有什么问题或想说的可以在这里讲哦~","path":"message/index.html","date":"12-30","excerpt":""},{"title":"search","text":"","path":"search/index.html","date":"12-30","excerpt":""},{"title":"标签","text":"","path":"tags/index.html","date":"12-30","excerpt":""}],"posts":[{"title":"基于Vue和Go的桌面端管理star应用","text":"这是一款基于Vue2和Golang的跨平台桌面端管理Star项目应用 前言:自己star的repo已经有100多个了, 有一天自己翻了一下列表, 想起来有一堆东西自己也不知道为什么当初star了…(应该是跟风大佬2333), 不过, 我个人认为, 一般在github上star别人的项目无非有以下几点: 这个项目在当前或者之后的项目中用到, star了以防自己以后忘记找不到(比如前端经常用到的一堆npm包那种) 要对这个项目的源码实现等进行研究细读(比如Vue, React之类的) 实用型项目(比如SS, lantern, 还有一些开车项目之类的…) 开源书籍文档之类的 其他原因, 比如出于对作者的鼓励, 或者就是跟风大佬star, 或者就是认识的人互粉这样的… 至于fork别人的项目, 一般就是你要进行一些对应的修改, 然后将修改PR到原项目中, 才是进行fork的, 这个倒没有必要细究了 我star项目的原因主要是前面三种, 但是star的一多自己也给忘了, 感觉这样不好, 于是想写一个方便自己管理star项目的客户端 正好自己没怎么写过桌面端应用, 也算是一次实践练习了, 项目地址https://github.com/ZEROKISEKI/starsManager/ 技术选用:桌面web化的一般可以用electron作为支持, 而前端方面稍微会写一点的就是vue, 那么有一个对应的支持electron-vue, 但是一般我们知道, 与系统API的交互由electron提供的API或者是有node.js去搞, 然后通过ipc之类的进行消息传递, 而由于最近是入门了golang, 所以在想能不能用前端代码去写用户表现, 而用golang作为系统API交互支持, 然后就找到了go-astilectron这个项目: Thanks to go-astilectron build cross platform GUI apps with GO and HTML/JS/CSS. It is the official GO bindings of astilectron and is powered by Electron. Go和Javascript可以通过sendMessage和OnMessage等接口进行消息的传递, 接下来是前端的选择, 如下所示, 其中parcel, vuetify, pouchdb都是第一次使用: Vue全家桶系列: Vue2 + Vue-router + Vuex + Vue-i18n前端模块打包构建: parcelUI框架: Vuetify(一款渐进式Material Design框架)前端数据库: Pouchdb网络请求: axios代码高亮和markdown渲染: github-markdown-css(自己造轮子不如用别人的轮子系列) 项目构建:首先你得安装了Golang, 并且设置好了$GOROOT和$GOPATH等变量, 如果没有配置过, 那么可以参考build-web-application-with-golang教程配置 如果上面的部分已经配置好了, 那么接下来要安装go-astilectron相关依赖: $ go get -u github.com/asticode/go-astilectron $ go get -u github.com/asticode/go-astilectron-bundler/... $ go get github.com/ZEROKISEKI/go-astilectron-bootstrap 在天朝的话, 上面get的过程八成会遇到这个错误 unrecognized import path &quot;golang.org/x/ ...&quot; 关于这个错误, 如果不能翻墙的话, 可以用golang的github镜像库去解决: $ mkdir -p $GOPATH/src/golang.org/x $ cd $GOPATH/src/golang.org/x $ git clone https://github.com/golang/crypto.git $ git clone https://github.com/golang/net.git $ git clone https://github.com/golang/sys.git git clone完之后可以重新go get, 应该就可以了, 此时可以通过bundler命令进行桌面可执行文件生成, 但是我们要先进行前端部分的build, 如果你没有安装parcel, 那么先全局进行安装parcel: yarn global add parcel-bundler or npm install parcel-bundler -g 进行build: $ cd src $ yarn or npm install $ npm run build 接下来可以可以bundler了: $ cd .. $ astilectron-bundler -v 上面那一步会去下载astlectron和electron, 天朝的话八成又会出问题了, 就是download没速度或者过于缓慢导致failed, 针对这点, 可能这样: 首先, 在当前项目建立一个文件夹, 比如cache_astilectron_bundler, 然后在bundler.json中添加一行代码: “cache_path”: “cache_astilectron_bundler” 然后可以在https://github.com/electron/electron/releases?after=v1.8.2-beta.2找到对应你系统的electron 1.8.1的版本, 放在cache_astilectron_bundler中, 并且做以下更名: electron-windows-amd64-1.8.1.zip(windows系统) electron-darwin-amd64-1.8.1.zip(OSX系统) electron-linux-amd64-1.8.1.zip(linux系统) 在https://github.com/asticode/astilectron/releases下载astilectron的0.20.0版本, 同样放在cache_astilectron_bundler中, 更名为: astilectron-0.20.0.zip 当然, 如果你想在同一台pc同时bundler三个系统的版本, 那么要下三个对应版本的electron 1.8.1, 并且做上面的更名, 都放在cache_astilectron_bundler中, 然后在bundler.json中添加以下代码: &quot;environments&quot;: [ {&quot;arch&quot;: &quot;amd64&quot;, &quot;os&quot;: &quot;darwin&quot;}, {&quot;arch&quot;: &quot;amd64&quot;, &quot;os&quot;: &quot;linux&quot;}, {&quot;arch&quot;: &quot;amd64&quot;, &quot;os&quot;: &quot;windows&quot;} ], 接下来应该可以bundler生成对应的二进制可执行文件了.默认生成地址是在当前项目的output文件夹中 项目演示:登录可以选择英文或者中文: 使用OAuth登录后, 可以看到你已经starred的repo的分类(按language): 代码文件和markdown文件均进行了渲染, 并且写了一个directive, 防止无法加载如./xxx,../xxx,#xxx这种url地址: 研究了octotree的部分源码, 自己也写了个可以查看项目代码树的组件: 自定义分类: 离线环境下可以查看之前加载过的文件: 后记:第一次使用parcel, 号称零配置构建真不是盖的, 但是在使用的过程还是出现了问题, 主要是vuetify.css/vuetify.min.css中有些样式使用了诸如display: -webkit-box; -webkit-box-orient: vertical;的写法, 而这种方式无论是在autoprefixer还是压缩css的cssnano中都已废除, 会直接将这样的代码删除, 而parcel的build默认采用了cssnano, 不使用它的方法只能是--no-minify, 但是这样的话所有的文件都没有压缩, 打包出来的js文件有几m大小(不过还是用file路径, 所以没什么影响) go-astilectron加载file path文件进行github oauth, 主要是通过new一个地址为github oauth authorize的window, 然后监听webcontents.will.navigate和webcontents.get.redirect.request这两个事件, 将oauth返回的code去请求token, 再进行消息传递给主窗口, 主窗口再SendMessage给前端token, 就完成了oauth的过程, 然而go-astilectron没有这两个事件的支持, 于是提了个PR添加了这两个事件的支持, 顺带也写了个demo, 不过目前go-astilectron还是有很多未完善的东西, 所以后面会出现什么坑我也不是很清楚(如果遇到坑就补) 检测离线状态(主要是为了避免离线状态下还request的情况)一开始打算用的navigator.online, 但是这东西返回false的时候没问题, true的时候不一定是能上网的(比如你启用了VMware Network), 于是用go写了个与api.github.com进行tcp连接的dial, 进行离线状态检测, 在mac下无问题, 但是在windows下会出现cannot read Webcontents of undefined的问题, 这个问题还需修正 感觉每一次用新的东西都是踩坑的过程2333, 如果感兴趣的话, 欢迎star","path":"2018/04/23/StarsManager/","date":"04-23","excerpt":"这是一款基于Vue2和Golang的跨平台桌面端管理Star项目应用","preview":"http://p1r8dwfrm.bkt.clouddn.com/基于Vue和Go的桌面端管理star应用/preview.jpg"},{"title":"AndroidManifest Ambiguity方案实现","text":"最近还是有些忙的, 刚好需要做资源保护这一方面的东西, 顺便记录一下Ambiguity方案的一个实现过程, 回头自己忘了也可以看下, 不过资源保护这东西, 针对性还是比较强的,需要不断地有新套路, 不过对于不懂资源文件的人来说还是有一定阻挡作用的… AndroidManifest Ambiguity这个方案实际上就是一张图: 这张图的大致意思是, AndroidManifest.xml中的属性是有对应的属性名(name)和对应的Res Id号的, 比如android:name=”xxxx”这个属性, 有一个对应的属性名(不是android:name)和对应的Res Id号(就是我们反编译经常看到的0Xxxxxxxx之类的), 当Res Id号为0(或者为一个不合法的值,比如0x01017FFF), Android系统是不会对齐进行解析的, 会无视这个属性, 但是对于apktool来说, 是会解析这个属性的, 这样的话虽然反编译的时候没什么问题, 但是在重打包的时候会因为非法Res Id导致重打包失败, 从而对app进行一定程度的保护。 那么, 要搞懂或者实测这个方案, 先要对AndroidManifest.xml这个文件了解才行, 一般说AndroidManifest.xml, 都会用看雪的某张图: 以一个示例APK的AndroidManifest.xml进行说明重点的部分 总体的(就是上面那张神图的中间的方块): Magic Number -&gt; 4Bytes, 固定的值0x00080003, 可以看做标识, 上图前四个字节 File Size -&gt; 4Bytes, 整个AndroidManifest.xml的字节数, 在上图是0x00000938 接下来就是StringChunk了, 我把图稍微截大点: Chunk Type -&gt; 4Bytes, 固定的值0x001C0001, 上图的0x8-0xB位 Chunk Size -&gt; 4Bytes, 整个StringChunk的大小, 上图的0xC-0xF位0x0000550 String Count -&gt; 4Bytes, 字符串数目, 上图的0x10-0x13位0x00000022, 表示有34个字符串 Style Count -&gt; 4Bytes, 样式数目, 上图的0x14-0x17位0x00000000, 表示有0个样式 UnKnown -&gt; 4Bytes, 固定值0x00000000, 没用的东西 String Pool Offset -&gt; 4Bytes, 字符串起始偏移, 这个是相对StringChunk的, 以上图为例, String Pool Offset为0x000000A4, 则起始偏移 = A4 + 8 = AC Style Pool Offset -&gt; 4Bytes, 样式起始偏移, 也是相对StringChunk的, 上图0x20-0x23为0x00000000, 表示没有Style String Offset数组 -&gt; String Count * 4Bytes, 以上图为例, 大小为 0x22 * 4 = 88, 上图的String Offset数组范围为0x24 - 0xAB Style Offset数组 -&gt; Style Count * 4Bytes, 跟String Offset相同, 这个例子明显没有这一块 String Data -&gt; 字符串数据块, 下面分析 Style Data -&gt; 样式数据块, 下面分析 首先分析String Offset数组, 上面我们说了范围是0x24-0xAC, 那么先取0x24-0x27这四位, 即第一个字符串的偏移, 为0x00000000, 即为0 + String Pool Offset + 8 = 0 + A4 + 8 = AC, 那么看一下上图的0xAC位: 0B 00 76 00 65 00 72 00 73 00 .... 这里我们要说明一个字符串在AndroidManifest.xml的存储方式是UTF16, 并且前面是先存字符数目, 最后填充00(相当于\\0这种东西): 比如有一个字符串fuck, 转为十六进制ASCII码即为66 75 63 6B, 转为UTF16则为66 00 75 00 63 00 6B 00, fuck字符为四个, 那么加上04 00, 最后填充00 00, 就成了: // fuck的最终存储形式 04 00 66 00 75 00 63 00 6B 00 00 00 这里我圈了出来: 对于Style, 跟String的分析是一样的, 可以自己拿个APK看下。 然后就是ResourceChunk了: Chunk Type -&gt; 4Bytes, 固定值0x00080180, 看0x00000558 - 0x0000055B位 Chunk Size -&gt; 4Bytes, 整个ResourceChunk的大小, 以上图为例, 0x0000055C-0x0000055F位, 为0x0000002C ResourceIds数组 -&gt; ChunkSize / 4 - 2个, 每个4Bytes, 表示对应的Res Id值 中间有个String NameSpace Chunk 部分, 可以跳过也可以停下来看下, 范围为0x00000584 - 0x0000059B: Chunk Type -&gt; 4Bytes, 固定值0x00100100 Chunk Size -&gt; 4Bytes, 这里上图的值为18即24个字节, 所以范围是0x00000584-0x0000059B Line Number -&gt; 4Bytes Unknown -&gt; 4Bytes Prefix -&gt; 4Bytes Uri -&gt; 4Bytes 最后是TagChunk部分, TagChunk有很多个Chunk(Start Tag Chunk 或者End Tag Chunk), 按示例是从0x0000059C开始: Chunk Type -&gt; 4Bytes, 有两个固定值, 为0x00100102表示这是一个Start Tag, 0x00100103表示这是一个End Tag Chunk Size -&gt; 4Bytes Line Number -&gt; 4Bytes, 不知道什么用 Unknown -&gt; 4Bytes, 固定值0xFFFFFFFF, 没用的东西 Namespace uri -&gt; 4Bytes, 这个可以不管, 对应上面的String NameSpace Chunk Name -&gt; 4Bytes, 对应StringChunk的字符串索引 Flags -&gt; 4Bytes, 固定值0x00140014, 没什么用 Attr Count -&gt; 4Bytes, 这个Tag的属性数目 Class Attribute -&gt; 4Bytes, 不知道干什么 Attr 数组 -&gt; 数组元素数目为Attr Count, 每个Attr都是一个20字节的结构体, 所以总长度为Attr Count * 20 上面说Attr是个20字节的结构体, 这里进行简要说明: // uint32实际上表示是4Bytes type Attr struct { Uri uint32 // 对应字符串索引, 比如上图的&quot;application&quot;在字符串索引是0A, Application Tag Chunk所有的attr的uri都是0A Name uint32 // 这个很关键, 也是个索引, 但是同时表示String和Resource索引 String uint32 // 指向字符串索引, 当Type为0x03000008时与Data相等 Type uint32 // 类型, 比如0x030000008 表示这是个android:name Data uint32 // 数据 } 上面这些东西, 不能用光看的, 要自己用一个示例一步一步分析下来才会印象深刻些, 关于分析二进制文件的, 可以用C32ASM, 或者神奇010 Editor(导入AXMLTemplate,直接都给你分好了, 看起来更容易) 把上面的结构大致了解了以后, 我们需要定义一个方案实现, 分别是针对StringChunk, ResourceChunk, 以及Application TagChunk进行手术, 在本例中用go(js用多了, 速成go感觉很不适应规则)撸了一个, 首先是StringChunk模块: 1. 确定插入字符串a, b 2. 将字符串a, b插入string data块(需要对齐, 如果上面你仔细看, 会发现都是4Bytes的段, 而字符串是UTF16即2Bytes的, 所以要进行4Bytes对齐) 3. 计算两个字符串的偏移值, 添加进string offset数组中 4. 修改起始string offset值(+8, 因为第三步增加了8个字节, 所以起始偏移值要加8) 5. 如果有style的话(判断起始style offset是否为0), 那么起始style offset需要修正(+8 + 两个字符串的长度) 6. 修正string count 7. 修正string chunk size 8. 修正fileSize // 插入字符串aonosora.class, name func modifyStringChunk(axml * AXML, axmlBytes []byte) []byte { // UTF8ToUTF16() 将其转为可以塞进二进制文件的字符串: 0x0E 0x00 0x60 0x00 0x6F 0x00 .... 0x73 0x00 0x00 0x00 appendStr1 := UTF8ToUTF16([]byte{ 0x61,0x6F,0x6E,0x6F,0x73,0x6F,0x72, 0x61,0x2E,0x63,0x6C,0x61,0x73,0x73, }) // 同转为字符串: 0x04 0x00 0x6E 0x00 0x61 0x00 0x6D 0x00 0x65 0x00 0x00 0x00 appendStr2 := UTF8ToUTF16([]byte{ 0x6E,0x61,0x6D,0x65, }) // 计算出字符串data块长度 var strLen uint32 if axml.StyleOffset == 0 { // 没有style块的情况, string data块就是StringChunk的最后一块, 直接用ChunkSize去减 strLen = axml.StringChunkSize - axml.StringOffset } else { // 如果有Style的情况, 字符串data块为StyleOffset - StringOffset strLen = axml.StyleOffset - axml.StringOffset } // string data块的结尾偏移 strEndOffset := axml.StringOffset + 0x8 + strLen // 连续插入字符串 axmlBytes = append(axmlBytes[:strEndOffset], append(appendStr1, append(appendStr2, axmlBytes[strEndOffset:]...)...)...) // 对齐String, 一般在有Style的情况才有改变效果 // 因为String在这里是UTF16形式的, 而其他字段都是UInt32形式的, 所以要进行对齐 // 对齐的方式在StringData的后面插入00 strLenAlignedOffset := strLen strLenAligned := (strLenAlignedOffset + uint32(0x03)) &amp; (^uint32(0x03)) strLenAlignedOffset2 := strLenAligned + uint32(len(appendStr1)) strLenAligned2 := (strLenAlignedOffset2 + uint32(0x03)) &amp; (^uint32(0x03)) // 计算出对齐需要的空白字节数 alignBytesLen := strLenAligned2 - strLenAlignedOffset2 + strLenAligned - strLenAlignedOffset externSize := 0x8 + uint32(len(appendStr1)) + uint32(len(appendStr2)) strEndOffset = strEndOffset + uint32(len(appendStr1)) + uint32(len(appendStr2)) // 一次填充空白字节到string data块中 for i:= 0; i &lt; int(alignBytesLen); i++ { axmlBytes = append(axmlBytes[:strEndOffset], append([]byte{0x00}, axmlBytes[strEndOffset:]...)...) strEndOffset += 1 } externSize = externSize + alignBytesLen // 增加StringOffset偏移索引表 // 字符串aonosora.class的相对Offset // UInt32ToBytes()将一个UInt32转为一个长度为4的字节段 str1OffsetIndex := UInt32ToBytes(strLen) // 字符串name的相对Offset str2OffsetIndex := UInt32ToBytes(strLen + uint32(len(appendStr1))) // 计算出string offset数组的结尾offset strEndOffsetIndex := 36 + axml.StringCount * 4 // 填充两个新的字符串对应的偏移值 axmlBytes = append(axmlBytes[:strEndOffsetIndex], append(str1OffsetIndex, append(str2OffsetIndex, axmlBytes[strEndOffsetIndex:]...)...)...) axml.StringCount = axml.StringCount + 2 axml.StringOffset = axml.StringOffset + 0x8 // 修正StringOffset起始偏移 fixBytes(axmlBytes, axml.StringOffset, 28) // 修正StringCount fixBytes(axmlBytes, axml.StringCount, 16) // 有Style的情况要修正StyleOffset if axml.StyleOffset != 0 { axml.StyleOffset = axml.StyleOffset + externSize fixBytes(axmlBytes, axml.StyleOffset, 32) } // 修正StringChunkSize axml.StringChunkSize = axml.StringChunkSize + externSize fixBytes(axmlBytes, axml.StringChunkSize, 12) axml.FileSize = uint32(len(axmlBytes)) // 由于增加了字节, 原先的Offset需要重新设置 axml.ResourceChunkOffset = axml.ResourceChunkOffset + externSize axml.AppChunkOffset = axml.AppChunkOffset + externSize return axmlBytes } 然后是ResourceChunk, 这个简单些: 1. 由上一步计算出新的String Count(字符串个数), 让这个数减去现有Resource数得出需要填充的Resource个数 2. 需要填充的Resource全是非法的Res Id值 3. 修正ResourceChunkSize(+ 填充的Resource个数 * 4) 4. 修正FileSize func modifyResourceChunk(axml * AXML, axmlBytes []byte) []byte { resourceCounts := axml.ResourceChunkSize / 4 - 2 // 计算出需要填充的ResourceIds的个数, 全部填充为0x00即可, 因为字符串的个数远大于资源的个数, 所以用StringCount - resourceCounts paddingCounts := axml.StringCount - resourceCounts // 计算出从哪个偏移开始填充 paddedStartOffset := axml.ResourceChunkOffset + axml.ResourceChunkSize for i := 0; i &lt; int(paddingCounts); i++ { // 这里特别对第一个插入的字符串用了个Res Id的非法值(尽管0也是非法, 其实都可以用0) if i == int(paddingCounts) - 2 { axmlBytes = append(axmlBytes[:paddedStartOffset], append(UInt32ToBytes(uint32(0x01017FFF)), axmlBytes[paddedStartOffset:]...)...) } else { axmlBytes = append(axmlBytes[:paddedStartOffset], append(UInt32ToBytes(uint32(0x00000000)), axmlBytes[paddedStartOffset:]...)...) } paddedStartOffset = paddedStartOffset + 4 } // 修复ResourceChunkSize axml.ResourceChunkSize = axml.ResourceChunkSize + paddingCounts * 4 fixBytes(axmlBytes, axml.ResourceChunkSize, axml.ResourceChunkOffset + 4) axml.FileSize = uint32(len(axmlBytes)) // 增加字节改变Offset位置 axml.AppChunkOffset = axml.AppChunkOffset + paddingCounts * 4 return axmlBytes } 最后是Application TagChunk, 相对也简单些: 1. 构造出一个Attr 结构体(属性名和Res Id索引都是我们插入的最后一个字符串的索引值, URI为Application对应结构体的URI) 2. 直接插入到这个TagChunk中 3. 修正这个TagChunk的attr count(+1) 4. 修正这个TagChunk的Chunk Size(+20) 5. 修正FileSize func modifyTagChunk(axml * AXML, axmlBytes []byte) []byte { appChunkSize := BytesToUInt32(axmlBytes[axml.AppChunkOffset + 4: axml.AppChunkOffset + 8]) appChunkAttrCount := BytesToUInt32(axmlBytes[axml.AppChunkOffset + 28: axml.AppChunkOffset + 32]) // 取得AppChunk 结尾偏移 appChunkEndOffset := axml.AppChunkOffset + appChunkSize // 表明属性名为name, 属性值为Android:name = &quot;aonosora.class&quot; attr := new(Attr) attr.Uri = axml.AppURIIndex attr.Name = axml.StringCount - 1 attr.String = axml.StringCount - 2 attr.Type = 0x03000008 attr.Data = axml.StringCount - 2 attrRefValue := reflect.ValueOf(attr).Elem() for i := 0; i &lt; attrRefValue.NumField(); i++ { value := uint32(attrRefValue.Field(i).Uint()) axmlBytes = append(axmlBytes[:appChunkEndOffset], append(UInt32ToBytes(value), axmlBytes[appChunkEndOffset:]...)...) appChunkEndOffset += 4 } // 修正AppChunk Attr Count fixBytes(axmlBytes, appChunkAttrCount + 1, axml.AppChunkOffset + 28) // 修正AppChunk Size fixBytes(axmlBytes, appChunkSize + 20, axml.AppChunkOffset + 4) axml.FileSize = uint32(len(axmlBytes)) return axmlBytes } 跑一下程序, 运行出来是这个鬼样子(用的Android_Killer, 因为我特别对ShakaApktool进行了设置才能反编译, 不然连反编译都不行了, Android逆向助手跑出来是个空文件夹, ApkToolKit直接提示失败): 不过, 这种方式跟多数资源保护一样, 具有比较强的针对性(就是针对apktool这个东西), 很多的Android反编译工具(比如Android逆向助手, Android_Killer, ApkToolKit),看文件目录的话, 其实都差不多的(包含apktool, dex2jar, aapt这些基本的东西), 所以一防住apktool的话, 很多工具就是用不了的, 这对于隔离新手来说还是有用的, 缺点也是针对性比较强, 毕竟这种方式其实就是利用反编译工具的逻辑漏洞, 那么工具做一下更新就行了, apktool这个东西在github上是开源的: https://github.com/iBotPeaches/Apktool, 版本是不断更新的, 只要它做了对应的更新, 那么方案就无效了。 接下来又会匿一段时间了, 很多任务还没处理, 蛋疼。","path":"2018/02/02/ManifestAmbiguity/","date":"02-02","excerpt":"最近还是有些忙的, 刚好需要做资源保护这一方面的东西, 顺便记录一下Ambiguity方案的一个实现过程, 回头自己忘了也可以看下, 不过资源保护这东西, 针对性还是比较强的,需要不断地有新套路, 不过对于不懂资源文件的人来说还是有一定阻挡作用的…","preview":"http://p1r8dwfrm.bkt.clouddn.com/AndroidManifest-Ambiguity方案实现/preview.jpg"},{"title":"强推hooksoft生肉吐槽","text":"hooksoft的游戏是出了名的日常甜死你向作品, 目前貌似只汉化了lovely quest和 Strawberry Nauts,鉴于目前抠脚的日语水平, hooksoft的作品比较简单, 所以就推了meltymoment和sugirly wish两部作品,感觉就是… 太tm长了日常系的作品居然能有那么长的文本, meltymoment光是一个普通的什么管理委员会都能吹出那么多文本, 选项又鬼多, 又是选择地点又是RTC什么的…, 推了すみれ线后就不想再玩了, 毕竟其他角色真没什么进线的欲望(其实第一次玩的时候乱选到了共通线就结束了233, 然后又重新开始, 快进下过共通线都要30+分钟, 你说游戏长不长….), 顺便一提, 个人线的hs应该有十次那样, 堪比拔作了吧 不过, 拿来消遣放松倒是不错的选择, 其他线还是到时再玩吧 然后就是sugirly wish了, 首先那个幼驯染基本跟meltymoment基本一样, 我怀疑她搞完sugirly wish后就穿越到meltymoment去了2333, 其他的感觉没什么萌点, 目前就妹线比较感兴趣(我不是妹控), 由于是生肉, 推得还是比较慢的, 目前还没推完, 不过感觉这作还是差不多吧, 日常搞笑废萌系, 估计推完短期内我都不怎么想碰废萌了2333, 最后附送两张ひな的图~","path":"2018/01/10/hooksoft/","date":"01-10","excerpt":"hooksoft的游戏是出了名的日常甜死你向作品, 目前貌似只汉化了lovely quest和 Strawberry Nauts,鉴于目前抠脚的日语水平, hooksoft的作品比较简单, 所以就推了meltymoment和sugirly wish两部作品,感觉就是…","preview":"http://p1r8dwfrm.bkt.clouddn.com/hooksoft/preview.jpg"},{"title":"即将到来的2018","text":"还有两天, 就是2018了, 我也即将毕业2017做了什么？ 没做什么, 就是正常的大学过程，跟同学，跟朋友，实习等等然后就是, 在2017，终于踏入了gal的坑里面了, 这一年约莫有玩了30多部gal吧(虽然大多数都是单线)感觉不用操作的游戏更适合我了, 其他的游戏，倒是愿意去看别人的直播我读的是计算机专业, 还是很庆幸读这个专业, 这个专业算是培养了我去折腾东西的”兴趣“… 关于接下来的2018关于工作:大学里面关于IT, 学的算是比较杂, 主要玩的是前端, 如你所见这个blog的主题是自己写的, 玩过逆向工程, 玩过python等等之前自己的想法是主搞前端, 做一个前端程序员, 学其他的, 只是为了工作时能更方便罢了 不过, 去实习之后, 虽然做得不错, 但是发现我可能并不想当一名程序员, 虽然已经拿到了一些offer, 但是都不是很想去, 在家里人的劝说下, 去参加了2018的国考有点可笑, 说自己喜欢代码, 但又不想当程序员, 我自己都觉得矛盾, 可能就像《白马啸西风》李文秀的那句话那样: “那些都是很好很好的，可我偏偏不喜欢” 而考公选的是自己居住的城市(潮汕某三或四线城市), 一则求稳, 二则不想要那么快的生活节奏, 对小城市也没什么排斥感, 缓慢的生活节奏更适合我(至少目前是这么想) 关于兴趣和爱好:开始对很多领域感兴趣, 自从alphago横空出世以来, 开始掀起机器学习的热潮, 目前有一个很热门的东西叫tensorflow, 关于这方面挺感兴趣, 想找个时间学一下已经有相当长的时间没玩过逆向工程了, 会重新拾起这一方面的东西重新拾起python, 学习golang认真去学下日语, 毕竟汉化的gal已经满足不了我了2333, 顺便也当为研究下汉化做个铺垫 …再说下去我怕到时会不想再看这篇文章了 总之, 提前祝愿一下2018了。","path":"2017/12/30/helloWorld/","date":"12-30","excerpt":"还有两天, 就是2018了, 我也即将毕业2017做了什么？ 没做什么, 就是正常的大学过程，跟同学，跟朋友，实习等等然后就是, 在2017，终于踏入了gal的坑里面了, 这一年约莫有玩了30多部gal吧(虽然大多数都是单线)感觉不用操作的游戏更适合我了, 其他的游戏，倒是愿意去看别人的直播我读的是计算机专业, 还是很庆幸读这个专业, 这个专业算是培养了我去折腾东西的”兴趣“…","preview":"http://p1r8dwfrm.bkt.clouddn.com/helloworld/preview.jpg"}]}